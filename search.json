[{"title":"Stellar动态友链分组","path":"/posts/36ee0b0c/","content":"我们时常希望博客的友链界面能够对不同的友链分组；stellar的动态友链功能又十分强大，但所有导出的数据都会写入一个文件。这篇文章记录对动态友链生成仓库的改造，使之能够进行友链分类。 11月15日更新最新版本的动态友联已经支持输出到自定义文件，因此读者继续参考本文时请注意文章的时效性。 由于本文对于仓库源码有一定的改动，请先确认你是否确实有这个需求，而后再理性地选择是否魔改。 废话我就不多说了，我们直接开始。 fork动态友链抓取仓库 首先，你需要fork动态友链抓取仓库，链接如下： https://github.com/xaoxuu/issues-json-generatorhttps://github.com/xaoxuu/issues-json-generator 根据README内容完成配置。这里我就不多赘述了，需要保证你的workflow能够正确运行并且output分支能看到输出的data.json文件。 代码修改 在这个魔改中需要修改两部分内容(均处于main分支下)：config.yml和generator/main.py。这里先给出两者的文件： 提示在复制源码前，我建议你看看我都改了什么。这有助于你对代码有宏观的把握，也对程序中可能出现的问题有解决想法。 config.yml diff源文件 config.yml 12345678910111213 # 网络请求设置request: timeout: 10 # 超时设置 ssl: false # ssl设置# 要抓取的 issues 配置issues: repo: felixchen0707/friendLink_api # 仓库持有者/仓库名 label: active # 筛选具有 active 标签的 issue ，取消此项则会提取所有 open 状态的 issue+ className:+ - &#x27;ordinary&#x27;+ - &#x27;top&#x27; sort: updated-desc # 排序，按最近更新，取消此项则按创建时间排序 config.yml 12345678910111213 # 网络请求设置request: timeout: 10 # 超时设置 ssl: false # ssl设置# 要抓取的 issues 配置issues: repo: felixchen0707/friendLink_api # 仓库持有者/仓库名 label: active # 筛选具有 active 标签的 issue ，取消此项则会提取所有 open 状态的 issue className: - &#x27;ordinary&#x27; - &#x27;top&#x27; sort: updated-desc # 排序，按最近更新，取消此项则按创建时间排序 generator/main.py diff源文件 generator/main.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 # -*- coding: utf-8 -*-# author: https://github.com/Zfourfrom bs4 import BeautifulSoupimport osimport requestimport jsonimport configversion = &#x27;v2&#x27;outputdir = version # 输出文件结构变化时，更新输出路径版本- filename = &#x27;data.json&#x27;data_pool = []+ cfg = config.load()+ filter = cfg[&#x27;issues&#x27;]def mkdir(path): folder = os.path.exists(path) if not folder: os.makedirs(path) print(&quot;create dir:&quot;, path) else: print(&quot;dir exists:&quot;, path)- def github_issuse(data_pool):+ def github_issuse(data_pool, className): print(&#x27; &#x27;) print(&#x27;------- github issues start ----------&#x27;)+ print(&#x27;is catching label:&#x27; + className) baselink = &#x27;https://github.com/&#x27;- cfg = config.load()- filter = cfg[&#x27;issues&#x27;] try: for number in range(1, 100): print(&#x27;page:&#x27;, number) url = &#x27;https://github.com/&#x27; + filter[&#x27;repo&#x27;] + &#x27;/issues?page=&#x27; + str(number) + &#x27;&amp;q=is%3Aopen&#x27; if filter[&#x27;label&#x27;]:- url = url + &#x27;+label%3A&#x27; + filter[&#x27;label&#x27;]+ url = url + &#x27;+label%3A&#x27; + filter[&#x27;label&#x27;] + &#x27;+label%3A&#x27; + className if filter[&#x27;sort&#x27;]: url = url + &#x27;+sort%3A&#x27; + filter[&#x27;sort&#x27;] print(&#x27;parse:&#x27;, url) github = request.get_data(url) soup = BeautifulSoup(github, &#x27;html.parser&#x27;) main_content = soup.find_all(&#x27;div&#x27;, &#123;&#x27;aria-label&#x27;: &#x27;Issues&#x27;&#125;) linklist = main_content[0].find_all(&#x27;a&#x27;, &#123;&#x27;class&#x27;: &#x27;Link--primary&#x27;&#125;) if len(linklist) == 0: print(&#x27;&gt; end&#x27;) break for item in linklist: issueslink = baselink + item[&#x27;href&#x27;] issues_page = request.get_data(issueslink) issues_soup = BeautifulSoup(issues_page, &#x27;html.parser&#x27;) try: issues_linklist = issues_soup.find_all(&#x27;pre&#x27;) source = issues_linklist[0].text if &quot;&#123;&quot; in source: source = json.loads(source) print(source) data_pool.append(source) except: continue except Exception as e:- print(&#x27;&gt; end&#x27;)+ print(&#x27;&gt; end catching label:&#x27; + className)print(&#x27;------- github issues end ----------&#x27;)print(&#x27; &#x27;)# 友链规则+ for className in filter[&#x27;className&#x27;]:+ data_pool.clear()- github_issuse(data_pool=data_pool)+ github_issuse(data_pool=data_pool, className=className) mkdir(outputdir)- full_path = outputdir + &#x27;/&#x27; + filename+ full_path = outputdir + &#x27;/&#x27; + className + &#x27;.json&#x27; with open(full_path, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as file_obj: data = &#123; &#x27;version&#x27;: version, &#x27;content&#x27;: data_pool &#125; json.dump(data, file_obj, ensure_ascii=False, indent=2) generator/main.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 # -*- coding: utf-8 -*-# author: https://github.com/Zfourfrom bs4 import BeautifulSoupimport osimport requestimport jsonimport configversion = &#x27;v2&#x27;outputdir = version # 输出文件结构变化时，更新输出路径版本data_pool = []cfg = config.load()filter = cfg[&#x27;issues&#x27;]def mkdir(path): folder = os.path.exists(path) if not folder: os.makedirs(path) print(&quot;create dir:&quot;, path) else: print(&quot;dir exists:&quot;, path)def github_issuse(data_pool, className): print(&#x27; &#x27;) print(&#x27;------- github issues start ----------&#x27;) print(&#x27;is catching label:&#x27; + className) baselink = &#x27;https://github.com/&#x27; try: for number in range(1, 100): print(&#x27;page:&#x27;, number) url = &#x27;https://github.com/&#x27; + filter[&#x27;repo&#x27;] + &#x27;/issues?page=&#x27; + str(number) + &#x27;&amp;q=is%3Aopen&#x27; if filter[&#x27;label&#x27;]: url = url + &#x27;+label%3A&#x27; + filter[&#x27;label&#x27;] + &#x27;+label%3A&#x27; + className if filter[&#x27;sort&#x27;]: url = url + &#x27;+sort%3A&#x27; + filter[&#x27;sort&#x27;] print(&#x27;parse:&#x27;, url) github = request.get_data(url) soup = BeautifulSoup(github, &#x27;html.parser&#x27;) main_content = soup.find_all(&#x27;div&#x27;, &#123;&#x27;aria-label&#x27;: &#x27;Issues&#x27;&#125;) linklist = main_content[0].find_all(&#x27;a&#x27;, &#123;&#x27;class&#x27;: &#x27;Link--primary&#x27;&#125;) if len(linklist) == 0: print(&#x27;&gt; end&#x27;) break for item in linklist: issueslink = baselink + item[&#x27;href&#x27;] issues_page = request.get_data(issueslink) issues_soup = BeautifulSoup(issues_page, &#x27;html.parser&#x27;) try: issues_linklist = issues_soup.find_all(&#x27;pre&#x27;) source = issues_linklist[0].text if &quot;&#123;&quot; in source: source = json.loads(source) print(source) data_pool.append(source) except: continue except Exception as e: print(&#x27;&gt; end catching label:&#x27; + className)print(&#x27;------- github issues end ----------&#x27;)print(&#x27; &#x27;)# 友链规则for className in filter[&#x27;className&#x27;]: data_pool.clear() github_issuse(data_pool=data_pool, className=className) mkdir(outputdir) full_path = outputdir + &#x27;/&#x27; + className + &#x27;.json&#x27; with open(full_path, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as file_obj: data = &#123; &#x27;version&#x27;: version, &#x27;content&#x27;: data_pool &#125; json.dump(data, file_obj, ensure_ascii=False, indent=2) 如何配置className 在我的构想中，一个网站应该由两部分构成：网站状态和网站分类。前者通过active、404、suspend这类的label进行标记；后者则是你自定义的分类。 对于你自定义的分类名称，你需要写在config.yml中的className项中，例如我这里用ordinary和top来区分一般友链和置顶友链。经过配置后的className包含的元素会在执行action的时候依次被作为label单独抓取合适的友链，例如下图是我的友链仓库： 我的友链仓库 其中，标记为active的issue表示允许被抓取，而标记为top和ordinary的issue会在抓取top和ordinary的两批抓取中分别被抓取，来达到对友链分类的效果。 期望的运行结果 被标记为classA的友链将会输出至output分支下v2/classA.json文件中，其他情况类似。由于label的名字与输出文件的名字强相关，这也要求你不要用奇怪的符号作为label的内容。 一些些补充 每个issue对应两个label 由于我使用站点状态和站点分类来分别表示一个网站，因此每一个issue至少都有两个label标记。例如，你的config.yml中配置了： config.yml12issues: label: active 若你仅仅为一个issue打上了ordinary标记而没有加上active标记或者反之，则该issue都不会被读取到。 加快访问速度 由于直接访问github的速度极慢，你可以使用Vercel构建该仓库来达到加速访问的效果。在你的Vercel的面板界面(dashboard)新建项目，导入你的友链数据仓库并点击deploy。由于你的输出内容一般不在main分支但是Vercel却会默认构建main分支，你需要进行以下操作： 点开项目，进入Settings-&gt;Git界面，找到Production Branch配置项，将分支名称从main/master改成output。下次向output分支推送时，Vercel就会重新改为部署该分支了。 致谢 xaoxuu/issues-json-generator BeaCox的灵感","tags":["博客"],"categories":["博客"]},{"title":"利用Github Action部署博客","path":"/posts/477696ac/","content":"前言 刚开始建立博客的时候，我一直采取的是本地hexo g后hexo d推送到Github的仓库中。这是利用hexo搭建博客最简单的部署方式。然后后续发现，源文件在这种情况下很容易丢失，备份的话又显得比较麻烦。后来了解到Github Action的强大功能，加上阅读了这篇教程后，现在已经实现将源文件推送到某个Github仓库，而后由仓库自动执行Github Action推送静态文件到另一个仓库(一般是我们的.github.io仓库)来代替我们在本地完成hexo g -d操作，同时也能托管我们的源文件。由于上面那篇教程年代有些许久远，这篇文章主要提供能够直接抄作业的workflow供大家使用。 操作步骤 创建需要用到的仓库 首先需要创建两个仓库，一个用于存放源文件，另一个存放生成的静态文件。以我的为例，用felixchen0707/MyBlogSourceCode存放源文件，用felixchen0707/MyBlog存放静态文件。 提醒值得注意的是，你也可以在同一个仓库中创建两个分支，在两个分支中分别存放源文件和静态文件。但并不推荐这么做，因为若这样做，也就意味着你的源文件和静态文件只能同时为public或者private，而且github仓库数目也并没有那么紧张，分开存放利远大于弊。 生成密钥 由于对仓库的写入需要特别的权限，因此你需要生成密钥对。在bash键入如下命令： 你可以在当前文件夹下看到两个文件，分别为github-deploy-key和github-deploy-key.pub，前者为私钥，后者为公钥。 注意请务必保证私钥的保密性。 为仓库配置公钥和私钥 源文件仓库 首先前往源文件仓库配置私钥。在我提供的例子中，其为felixchen0707/MyBlogSourceCode。 源代码仓库 如上图所示，为其新建一个secret，名称为HEXO_DEPLOY_PRI，内容为github-deploy-key文件中的全部内容(全选Ctrl+A)。 静态文件仓库 然后，前往静态文件仓库配置公钥。在我提供的例子中，为felixchen0707/MyBlog。 注意如果使用Github\rPages托管可供访问的网站，这个仓库必须是你的用户名.github.io，以我为例，即felixchen0707.github.io。 静态文件仓库 如上图所示，添加Deploy Keys。Title为HEXO_DEPLOY_PUB，内容为文件github-deploy-key.pub的全部内容。同时，勾选下方的Allow Write Access来提供写入权限。若你没有勾选此选项，该密钥对没有写的权限。 注意这里添加的是Deploy Keys而非Secrets，一定不要搞错。 添加Workflow workflow模板 接下来，在你的博客根目录下新建一个文件夹，名为.github，其中存放的文件可以被github识别并且加以利用。新建.github/workflows/auto_deploy.yml编写workflow模板。其内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# /.github/workflows/auto_deploy.ymlname: CIon: push: branches: - masterenv: GIT_USER: felixchen0707 GIT_EMAIL: 3137181992@qq.com THEME_REPO: felixchen0707/hexo-theme-stellar THEME_BRANCH: main DEPLOY_REPO: felixchen0707/MyBlog DEPLOY_BRANCH: mainjobs: build: name: Build on node $&#123;&#123; matrix.node_version &#125;&#125; and $&#123;&#123; matrix.os &#125;&#125; runs-on: ubuntu-latest strategy: matrix: os: [ubuntu-latest] node_version: [16.x] steps: - name: Checkout uses: actions/checkout@v2 - name: Checkout theme repo uses: actions/checkout@v2 with: repository: $&#123;&#123; env.THEME_REPO &#125;&#125; ref: $&#123;&#123; env.THEME_BRANCH &#125;&#125; path: themes/stellar - name: Checkout deploy repo uses: actions/checkout@v2 with: repository: $&#123;&#123; env.DEPLOY_REPO &#125;&#125; ref: $&#123;&#123; env.DEPLOY_BRANCH &#125;&#125; path: .deploy_git - name: Use Node.js $&#123;&#123; matrix.node_version &#125;&#125; uses: actions/setup-node@v1 with: node-version: $&#123;&#123; matrix.node_version &#125;&#125; - name: Configuration environment env: HEXO_DEPLOY_PRI: $&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125; run: | sudo timedatectl set-timezone &quot;Asia/Shanghai&quot; mkdir -p ~/.ssh/ echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts git config --global user.name $GIT_USER git config --global user.email $GIT_EMAIL - name: Install dependencies run: | npm install - name: Deploy hexo run: | npm run deploy 现在对上述模板做出解释。name为workflow的名称，这是任意的。 触发时机 1234on: push: branches: - master 以上为workflow触发的时机，即当master分支有新推送时触发。这里是否是master由你的源文件仓库分支名决定，若为main，则你需要修改成： 1234on: push: branches: - main 环境变量 1234567env: GIT_USER: felixchen0707 GIT_EMAIL: 3137181992@qq.com THEME_REPO: felixchen0707/hexo-theme-stellar THEME_BRANCH: main DEPLOY_REPO: felixchen0707/MyBlog DEPLOY_BRANCH: main 以上为workflow运行期间的变量，各个值需要你重新设置。GIT_USER为你的Github名称，GIT_EMAIL为你的邮箱，上述两者为触发workflow部署时的提交信息内容。 THEME_REPO和THEME_BRANCH指定了你的博客主题，在workflow运行时会自动拉取主题代码。我强烈建议你fork一份主题仓库来避免主题仓库更新时配置文件落后的情况发生。 DEPLOY_REPO和DEPLOY_BRANCH指定了向何处推送生成的静态文件。这里即为你一开始创建的存放静态文件的仓库。 定制jobs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051jobs: build: name: Build on node $&#123;&#123; matrix.node_version &#125;&#125; and $&#123;&#123; matrix.os &#125;&#125; runs-on: ubuntu-latest strategy: matrix: os: [ubuntu-latest] node_version: [16.x] steps: - name: Checkout uses: actions/checkout@v2 - name: Checkout theme repo uses: actions/checkout@v2 with: repository: $&#123;&#123; env.THEME_REPO &#125;&#125; ref: $&#123;&#123; env.THEME_BRANCH &#125;&#125; path: themes/stellar - name: Checkout deploy repo uses: actions/checkout@v2 with: repository: $&#123;&#123; env.DEPLOY_REPO &#125;&#125; ref: $&#123;&#123; env.DEPLOY_BRANCH &#125;&#125; path: .deploy_git - name: Use Node.js $&#123;&#123; matrix.node_version &#125;&#125; uses: actions/setup-node@v1 with: node-version: $&#123;&#123; matrix.node_version &#125;&#125; - name: Configuration environment env: HEXO_DEPLOY_PRI: $&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125; run: | sudo timedatectl set-timezone &quot;Asia/Shanghai&quot; mkdir -p ~/.ssh/ echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts git config --global user.name $GIT_USER git config --global user.email $GIT_EMAIL - name: Install dependencies run: | npm install - name: Deploy hexo run: | npm run deploy 上述为workflow的具体流程，有几个部分值得你注意。 nodejs版本 不同的主题对于nodejs有不同的版本要求，你需要在node_version: [16.x]设置，此处是nodejs最新的稳定版本，能够满足大多数主题要求，当然，你可以指定你需要的版本。 拉取主题代码 123456- name: Checkout theme repo uses: actions/checkout@v2 with: repository: $&#123;&#123; env.THEME_REPO &#125;&#125; ref: $&#123;&#123; env.THEME_BRANCH &#125;&#125; path: themes/stellar 上述步骤中，Github会拉取主题代码，仓库已由THEME_REPO和THEME_BRANCH决定。其中，你需要修改path的值，若为themes/stellar，则相当于将主题代码拉取至/themes/stellar下。需要注意的是，这里要和你的站点配置文件_config.yml中如下配置保持一致： 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: stellar 添加.gitignore 此时，你只需要在博客根目录下键入： 将其初始化成为一个Git仓库。但提交时，有些文件是多余的，你可以将其写入.gitignore中，以下是一个例子： .gitignore123node_modules/themes/db.json 然后提交并指定分支： 然后绑定远程仓库： 最后推送即可： 常见问题 插件版本的更新 虽然我们并没有提交node_modules文件夹，但我们推送了package.json和package_lock.json。两个文件详细记录了我们下载的插件及他们各自的依赖，在执行workflow时，action会自动collect这些包；如果我们对于这些依赖包有更新的需求，可以配置dependabot，在如下位置开启它： dependabot启用位置 此时，.github下会生成如下文件： .github/dependabot.yml1234567version: 2updates:- package-ecosystem: npm directory: &quot;/&quot; schedule: interval: daily open-pull-requests-limit: 20 插件的更新会通过pr的方式告知你，你只需要merge即可。 或者你可以在本地升级插件版本，重新推送。 建议建议推送前先使用hexo s预览，因为例如hexo-abbrlink这类插件会在预览或生成站点时在MarkDown文件的头部增加新的键值对。 workflow运行提示action_bot无权限怎么办 请检查你是否安装了hexo-deployer-git插件，并且在配置文件中是否采取了ssh而非http连接： _config.yml123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: &#x27;git&#x27; repo: git@github.com:felixchen0707/MyBlog.git branch: main 我这么做还有什么好处？ 首先正如一开始所说的，你可以在部署时同时备份你的源文件。利用Action来部署站点，也使得你的本地环境并不依赖nodejs环境，例如你需要修改小错误时，完全也可以在手机上做到。当然，也并不是说利用Github Action部署就一定优越，大家可以按需食用。","tags":["博客"],"categories":["博客"]},{"title":"我的大一","path":"/posts/dfa590a7/","content":"可能是想利用闲下来的功夫哔哔点啥。 前言 大一的生活比我想象的更快，加上一直不间断的疫情，大一后半段的生活似乎也就是在食堂和寝室两点一线中结束的。由于能看到这个博客的人要不就是在现实生活中与我毫无接触，要么就是无话不谈的好朋友，所以也不害怕暴露少部分的个人信息了。大一的各种琐事也都在最近渐渐收尾，不如自己来总结一下吧。 第一次早八 看到2022级同学入学时令我佩服的精气神，我也不由得想起自己刚进入大学时的样子。许多细节我其实也记不太得，但是印象深刻的还是开学的第一堂高数课。那是我的第一个早八。早上大概七点二十分左右，整整五百人的大教室就快坐满人了，现在想想这个点我刚醒吧（笑）。其实当时我也是这些疯狂的人之中的一员。说起动机，也未必是对知识的渴求，而是对新生活环境的好奇。毕竟在高中，可能一屁股坐在凳子上以后都不怎么离开位置吧，跟大学课间跑课不能说一模一样，就是毫不相关。坐在教室里，看着周围新奇的环境和陌生的课本，有一瞬间觉得高中所付出的辛苦都是值得的。不得不说，一个还算可以的高考成绩确实把我送进了理想的学府，让我感受到了梦寐以求的环境和氛围。虽然第一节高数课确实把我心态搞炸了，但是当时的我，确实表现出了前所未有的积极向上。 我的高数破防时刻 专业预选 出于某些懂的都懂的原因，我们学校对于工科专业是一起招收，入学后再进行二次分流。或许现在看来，这并不是什么稀奇事了，这种招生方式只会越来越广泛地被采取。但对于当时的我来说，简直就是噩梦。现在我依稀记得综评出分的那天晚上，我失眠了。我尽可能的从各种途径寻找能去信息安全的最低分数，甚至让原本不喜欢询问别人的我去加学长联系方式询问一些信息。其实我自己很清楚，这些努力基本上都是徒劳的，高考分数已然决定了我的去向，并不是我能够改变的。最后只能填了适合我这个分数段所能选择的我认为最有兴趣和前景的专业———生物医学工程。我记得很清楚，公布预选结果的时候我正在上大学化学这门课程，我整个暑假都在惦记的事情终于落地，似乎也没有那么焦虑和忧郁了。 仔细想想我很多时候都是这个样子，其实很清楚自己的未来会朝着什么样的地方发展，但却依旧忧心忡忡。我并不害怕差的结果，但我害怕未知。 不确定性是我一直很厌烦的事情。对于这个结果，后来我也很平静地接受了，虽然这本不是我最期望的结果。但站在现在的时间点，必须承认的是，我确实在生医工学院度过了值得我深深记住的大一学年。 大一下 虽然接受了分流结果，但我依然努力寻找进信安的方式，大二上的专业调整是我唯一的机会。经过大一上一学期的学习，我的年排最终锁定在8/80.这是一个还算不错的成绩，但对于转信安来说，还是有点痴人说梦了。但是大一下，我们有转出平台的机会，换句话说，就是可以离开工科平台，去学其他的专业。因为疫情，金融专业放弃了面试考察，转而采取更为简单粗暴的按排名由高到低录取。这对我来说是个不小的诱惑。 当你无法选择自己喜欢的专业时，碰上宇宙金这个专业至少能保证不错的出路。 而对于我的排名，被成功录取的概率是很大的。当时我便在转出或等待大二上两个选择中纠结，毕竟后者有赌的成分。这也就是我0624这篇碎碎念的来源。如果将现在的我放在当时的情境下，即便过去五个多月，我依然不能给出准确的选择。但现在的我又很庆幸，当时的我没有因为眼前的另一条道路而选择退缩。 在我看来，尝试后的失败比自我放弃的失败更加值得尊敬。 我在生医工学联 整个大一的我基本都是围绕学积分在转，因此对于大学生活的多样和丰富我几乎没有什么感觉，反而是时常陷入焦虑的旋涡中。但唯一有一个选择是我从未后悔的，就是加入生医工的院学联。在这里，我真真切切感受到了社交间的温暖。许多人都曾在我面前抱怨过学生组织内部的腐烂，但对我而言，生医工学联带给我的是如同第二个家一般的温暖。由于院系小的缘故，学院每月都有固定的生日会，为当月生日的同学准备蛋糕；学联的同学们也经常性冒出很有想法的活动点子，使得我们学院看上去像是天天在搞活动；各部门内部的例会硬生生会被我们组织成团建的样子。诸如此类，还有很多。在这里，我确实认识了一帮很有意思的人们，以及很优秀的值得尊重的其他同学。我想如果有什么是让我依旧怀念的，生医工团学联可能占据了很大一部分。 大一结束 如今，虽然已经到了大二第一学期期中了，但我大一所担心的一切事物，都才刚刚结束。我达到了我一年前想都不敢想的高度，也为我日日胆战心惊所焦虑的事情交出了还算不错的答卷。我转去了我当初心心念念的信息安全，选拔上了金融的辅修，也在生医工的学联完成了我完完全全策划一场活动的梦想。我开始真正接触信息技术，我认识了一大批值得尊敬的同学，我遇上了不少我可能这辈子都不会忘记的教授。走上一个新的阶段，就意味着过去的一切已经被慢慢封存，而未来的路还等着我慢慢开辟。我可能会陷入新的痛苦，也有可能收获新的喜悦；我可能会受到挫折的历练，也可能体会到苦尽甘来的惊喜。不论如何，很多事都要我自己去闯。 未来的好坏我无法预知，但未来一直在我的手中。","tags":["碎碎念"],"categories":["碎碎念"]},{"title":"记录第一次手搓css","path":"/posts/f6755936/","content":"手搓一次css以后，最大的感受就是：再也不想写css了。 起因 事情的起因是，Bowen跟我说，他用tailwindcss重新写了个主页，后来效果确实不错。看了看自己的主页，感觉有点太花里胡哨了。其实早些时候我特别喜欢花里胡哨，现在可能年纪大了吧。 后来看到了一位巨佬的主页，简洁得深得我心()。于是便仿照着极简的风格准备手搓。 困难 遇到的困难是，我在这之前 从来没有写过css。键盘上写下的每一行代码都是我最后的倔强。什么margin啊，display啊，彻底把我击垮了。问题在于，我甚至不能参考那位大佬的源码，用react写完生成的代码，甚至连一个css都没有。 接着就是各种翻手册、一点点尝试、打开各种连接找各种可能的解决方法。终于做出了初版： 初版效果 事情本该到此结束了，这个风格好看也算不上，但说丑也不至于(?)。但在手机端这个效果真的是拉垮，后来才发现，我所有的宽度什么的设置全部用了px。大寄特寄了属于是。 后来 凌晨一点，揉着眼睛把css全部换了百分比，用Bowen的话说就是： 最简单的响应式 一想确实如此，低级是低级了点，反正一般人看前端也看不到我的代码(bushi)。 结果 现在已经正式作为个人主页啦！感觉效果还不错，很干净。能力不支持复杂了不管怎么说也是第一次从零开始写css，还是比较满意的。","tags":["css"],"categories":["写码经历"]},{"title":"在django中实现websocket","path":"/posts/79d21042/","content":"本文在django中实现websocket协议。 在django中使用websocket 纯净的django是不支持websocket的，要想实现websocket协议，我们需要更改一些配置。 Step1: 安装第三方包 第三方包channels提供了在django中实现websocket通信协议的方式。我们安装这个包： 然后，我们前往settings.py下注册这个app： 123456789101112INSTALLED_APPS = [ &#x27;django.contrib.admin&#x27;, &#x27;django.contrib.auth&#x27;, &#x27;django.contrib.contenttypes&#x27;, &#x27;django.contrib.sessions&#x27;, &#x27;django.contrib.messages&#x27;,- &#x27;django.contrib.staticfiles&#x27;+ &#x27;django.contrib.staticfiles&#x27;, # MyApp+ &#x27;channels&#x27;] 一定要注意这里的逗号，千万不要遗漏，否则django会将没有被逗号分隔开的两个应用视作一个应用。 Step2: 配置asgi 前往项目的settings.py下配置asgi： 12WSGI_APPLICATION = &#x27;&#123;ProjectName&#125;.wsgi.application&#x27;+ ASGI_APPLICATION = &#x27;&#123;ProjectName&#125;.asgi.application&#x27; 然后前往asgi.py下更改默认配置，删除全部内容改写为： 1234567891011121314151617181920&quot;&quot;&quot;ASGI config for Project0728 project.It exposes the ASGI callable as a module-level variable named ``application``.For more information on this file, seehttps://docs.djangoproject.com/en/4.0/howto/deployment/asgi/&quot;&quot;&quot;import osfrom django.core.asgi import get_asgi_applicationfrom channels.routing import ProtocolTypeRouter, URLRouterfrom . import routingsos.environ.setdefault(&#x27;DJANGO_SETTINGS_MODULE&#x27;, &#x27;&#123;ProjectName&#125;.settings&#x27;)application = ProtocolTypeRouter(&#123; &quot;http&quot;: get_asgi_application(), # http路由列表 &quot;websocket&quot;: URLRouter(routings.websocket_urlpatterns), # websocket路由列表&#125;) Step3: 配置路由和视图类 在settings.py同级目录下新建routings.py，其功能相当于urls.py，专门负责websocket协议的路由： 123456789&quot;&quot;&quot;routings.py&quot;&quot;&quot;from django.urls import pathfrom &#123;应用名称&#125; import consumerswebsocket_urlpatterns = [ path(&#x27;&#123;URL&#125;&#x27;, consumers.&#123;视图类&#125;.as_asgi()),] 然后，前往需要使用到websocket的应用下新建consumers.py，其功能相当于views.py： 12345678910111213141516171819from channels.generic.websocket import WebsocketConsumerfrom channels.exceptions import StopConsumerclass &#123;类名&#125;(WebsocketConsumer): def websocket_connect(self, message): # 客户端发来链接请求后自动执行 # 允许创建链接 self.accept() def websocket_receive(self, message): # 客户端发来数据后自动执行 pass def websocket_disconnect(self, message): # 客户端断开wb链接时自动触发 # print(&quot;断开连接&quot;) raise StopConsumer() 以上是默认的结构，当然，你可以在routings.py中配置多个路由，然后在consumers.py中声明多个类。 运行程序并检查 此时我们运行程序，发现控制台输出变成了： 1234August 02, 2022 - 16:12:48Django version 4.0.6, using settings &#x27;Project0728.settings&#x27;Starting ASGI/Channels version 3.0.5 development server at http://127.0.0.1:8000/Quit the server with CTRL-BREAK. 说明此时django项目同时支持http协议和websocket协议了。 前后端数据交互 后端 后端对于websocket的操作相对较少，大多是对于数据的处理。主要用到的是self.send()和self.close()。 self.send()，向建立连接的客户端发送数据，参数即为准备发送的数据。 self.close()，服务端主动与客户端关闭连接。该函数被执行后，需要追加return停止函数继续运行。客户端接收到断开连接的请求后，客户端断开连接，同时，由于断开连接，服务端会自动执行websocket_disconnect()函数，然后抛出异常StopConsumer()，终止websocket连接。 前端 创建websocket连接 前端可以主动与目标url创建websocket连接。首先需要新建一个WebSocket对象，初始化参数是目标url。 1ws = new WebSocket(&quot;ws://127.0.0.1:8000/room/123/&quot;); 该请求匹配到后端的路由： 1path(&quot;room/&lt;int&gt;/&quot;,consumers.ChatRoom.as_asgi()) 于是执行 123456&quot;&quot;&quot;consumers.py&quot;&quot;&quot;class ChatRoom(WebsocketConsumer): def websocket_connect(self, message): self.accept() # 执行这句语句，即连接创建成功 此时，前端可以使用ws.send()发送数据了。 回调函数 当发生连接请求、传递数据、断开连接请求时，后端都有对应的函数会自动执行，前端也如此。这被称为回调函数。回调函数在满足条件后自动触发，JavaScript中可以为websocket绑定三种回调函数。 如果ws是websocket的一个实例化对象，那么可以使用ws.onopen、ws.onmessage、ws.onclose绑定函数。例如： 123456ws.onmessage = function(event)&#123; let tag = document.createElement(&quot;div&quot;); tag.innerText = event.data; document.getElementById(&quot;msg&quot;).appendChild(tag); console.log(&quot;已展示最新数据&quot;);&#125; 上述函数在后端主动发送数据后被自动执行，结果是向id为msg的块级内容写入新的元素。其中，event封装了后端发送的所有数据，利用event.data可以提取出数据。 更多地，onopen发生在建立连接后，onclose发生在收到后端关闭连接请求后。 多客户端的管理：聊天室为例 更改配置文件 使用channel_layers，可以对同时连接的多个客户端进行管理。相关的数据需要被写入内存当中，因此需要在配置文件中添加： 123456789&quot;&quot;&quot;settings.py&quot;&quot;&quot;CHANNEL_LAYERS = &#123; &quot;default&quot;: &#123; &quot;BACKEND&quot;: &quot;channels.layers.InMemoryChannelLayer&quot;, &#125;&#125; 将新连接的客户端写入内存中 我们需要将新建立的连接写入内存。对实例对象调用channel_layer.group_add()方法。例如： 12345from asgiref.sync import async_to_syncdef websocket_connect(self, message): # 将连接加入组中，self.channel_name表示在该组中该连接的名称。 async_to_sync(self.channel_layer.group_add)(&#123;加入的组名&#125;, self.channel_name) 其中，由于上述方法只支持异步，然而我们并没有编写异步代码，因此需要使用同步的方式完成该操作。asnyc_to_sync是将方法由异步转变成为同步。 获得新消息时，对同一组内所有连接群发消息，可以使用group_send()完成。例如： 123def websocket_message(self, message): # 对组名中所有连接对象调用方法名所对应的方法，字典作为参数传入 async_to_sync(self.channel_layer.group_send)(&#123;组名&#125;,&#123;&quot;type&quot;: &#123;方法名&#125;,&quot;message&quot;: message&#125;) 如果方法定义为： 12def &#123;方法名&#125;(self, event): self.send(event[&#x27;message&#x27;][&#x27;text&#x27;]) 也就意味着对群组内所有连接都发送message['text']。 断开连接时，需要从组内同时剔除该连接。可以使用： 12def websocket_disconnect(self, message): async_to_sync(self.channel_layer.group_discard)(&#123;组名&#125;, self.channel_name) 这样，当连接终止时，自动触发websocket_disconnect，该连接就从group中被剔除了。","tags":["python","django","websocket"],"categories":["学习笔记"]},{"title":"django笔记(4)：为ModelForm表单添加样式、如何拼接GET参数","path":"/posts/347baf21/","content":"为django中的modelform添加样式。 写在前面 最近的开发学习碰到了两个比较重要的知识点：ModelForm表单和后端URL拼接。这两点不算太难但也比较复杂，并且在后续开发也很常用。常不常用我不知道，反正我第一次是写懵了所以在这里总结一下这部分知识点。 正文 ModelForm表单 得益于ModelForm表单，我们不必在前端写复杂的html代码来实现表单。我们只需要一个简单的循环，以及对每一个字段的引用就可以做到了： 1234567891011&lt;form method=&quot;post&quot; novalidate&gt; &#123;% csrf_token %&#125; &#123;% for field in form %&#125; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputEmail1&quot;&gt;&#123;&#123; field.label &#125;&#125;&lt;/label&gt; &#123;&#123;field&#125;&#125; &lt;span style=&quot;color: red&quot;&gt;&#123;&#123; field.errors.0 &#125;&#125;&lt;/span&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;button type=&quot;submit&quot; class=&quot;btn btn-success&quot;&gt;确认提交&lt;/button&gt;&lt;/form&gt; 但是正是因为input框由django的ModelForm为我们自动生成，为其添加样式(例如BootStrap)就变得比较困难。在django中存在解决这个问题的途径。 第一种：修改ModelForm类的widget属性 widget属性决定了每一个字段通过django渲染出的html代码格式。例如要为username字段添加class=\"form-control\"的类名，那么我们就可以在定义ModelForm类时： 12345678class ExampleModelForm(models.ModelForm): class Meta: model = models.Administrator fields = [&quot;username&quot;] widgets = &#123; &quot;username&quot;: forms.CharField(attrs=&#123;&quot;class&quot;:&quot;form-control&quot;&#125;) &#125; 在字典中我们还可以添加其他键值关系，这样在前端渲染input时，就会带上我们所指定的class=\"form-control\"。同样的，在widgets字典中还可以指定多个字段自己的widget属性。 但是这样做会带来一个问题，例如我们对所有输入框都要应用BootStrap的样式，那么在widgets中逐个添加是否有些繁琐了呢？当然，我们也有办法解决这个问题。 第二种：重写__init__方法 在创造这个ExampleModelForm类时，其存在默认的__init__(self)方法。我们重写这个方法。 123456789101112131415class BootStrapModelForm(forms.ModelForm): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) # 循环每个字段为其插件进行设置 for name, field in self.fields.items(): # 字段中有属性，则增加 if field.widget.attrs: field.widget.attrs[&quot;class&quot;] = &quot;form-control&quot; field.widget.attrs[&quot;placeholder&quot;] = field.label else: field.widget.attrs = &#123; &quot;class&quot;: &quot;form-control&quot;, # 还可以添加其他的标签，例如placeholder &quot;placeholder&quot;: field.label &#125; 对上述代码做出一些解释。super().__init__(*args,**kwargs)是必须执行的，其初始化父类。然后，我们对存在的所有字段进行遍历，并对其中的field设置widget。其中，判断句if是为了防止覆盖原本的attrs属性。对于重写后的__init__(self)方法，我们可以单独将其作为一个父类，之后需要使用的所有ModelForm都改为继承此父类即可。 拼接URL 在访问url时，许多网站采用GET方式传参，这种参数一般显式地拼接在url后，例如 https://127.0.0.1:8000/index/?page=4 在开发中，这样的参数可能不止一个，对于多个参数，在点击超链接时为了防止参数的损失，解决方式之一就是对超链接进行后端的拼接。django自然也支持这个操作。例如我们需要对上述url拼接一个key=12的参数使得其能够携带两个参数，我们首先要获取已有的参数。在访问url时，request变量会携带所有与这次url访问有关的信息，因此，我们要从这里动手脚。当然，出于保护机制，django不允许直接修改request的值，因此，我们需要拷贝一份。 1query_dict = copy.deepcopy(request.GET) 说明一下上一行代码：request.GET携带了以GET方式传递的所有参数，其类型是一个字典。然后，我们要对query_dict添加键值关系，setlist()方法支持这种操作。例如我们来添加key=12。 1query_dict.setlist(&quot;key&quot;, 12) 这样，新的键值关系就被我们添加完成了。此时query_dict的值应该是 1234query_dict = &#123; &quot;page&quot;: 4, &quot;key&quot;: 12&#125; 最后，我们拼接url。 1234url = &quot;https://127.0.0.1:8000/index/?&#123;&#125;&quot;.format(query_dict.urlencode())print(url)# &quot;https://127.0.0.1:8000/index/?page=4&amp;key=12&quot;","tags":["python","django"],"categories":["学习笔记"]},{"title":"快速生成requirements.txt","path":"/posts/3c469774/","content":"前言 众所周知，Python的运行效率是不高的。但为什么Python还是很广泛地被使用呢？那当然是成熟的第三方库的加持！可以说Python的第三方库只有你想不到，没有他做不到的。因此，对于一个自己的或者是clone来的项目，下载依赖包就显得非常之重要。 快速生成requirement.txt 首先我们用包管理工具pip安装生成requirements.txt的插件。 然后一行简单的命令就可以快速生成requirements.txt啦！ 比起传统的pip freeze &gt; requirement.txt这句命令，上面可以做到虚拟环境之间相互隔离！也就是说，生成的requirements.txt只会包含当前项目用到的包，也很合常理对吧？ 偶尔水一水也不会有事的吧？","tags":["Python"],"categories":["编程技巧"]},{"title":"django学习笔记(3)：models数据类型处理","path":"/posts/f5da62aa/","content":"如何在django中处理不同的数据类型？ 前言 django通过继承models类来完成数据库表的创建，其中牵涉了很多数据类型和相关的知识点，这里把最近碰到的记录一下。 Django中数据类型的处理 首先来看一下最近一个练手项目(用户管理系统)中基础的部门表和用户表的定义。 1234567891011121314151617181920212223242526from django.db import models# 员工管理系统class Department(models.Model): &quot;&quot;&quot;这是部门的表：id, title&quot;&quot;&quot; title = models.CharField(verbose_name=&#x27;标题&#x27;, max_length=32)class UserInfo(models.Model): &quot;&quot;&quot;员工表&quot;&quot;&quot; name = models.CharField(verbose_name=&#x27;姓名&#x27;, max_length=16) password = models.CharField(verbose_name=&#x27;密码&#x27;, max_length=64) age = models.IntegerField(verbose_name=&#x27;年龄&#x27;) account = models.DecimalField(verbose_name=&#x27;账户余额&#x27;, max_digits=10, decimal_places=2, default=0) create_time = models.DateTimeField(verbose_name=&#x27;入职时间&#x27;) depart = models.ForeignKey(to=&quot;Department&quot;, to_field=&quot;id&quot;, on_delete=models.CASCADE) # 性别选项 gender_choices = ( (1, &quot;男&quot;), (2, &quot;女&quot;), ) gender = models.SmallIntegerField(verbose_name=&quot;性别&quot;, choices=gender_choices) 针对上面出现的类型，这里做一些相应地解释。 CharField CharField是基础的字符串类型，上述案例中，verbose_name=参数在许多函数中都出现了，实际上，这个参数主要是便于开发者自己了解每一个字段代表什么含义，由于我们是Django开发，因此我们使用注释的方案也可以，具体看个人喜好。对于CharField来说，max_length=是必要的，因为在创建MySQL表时，我们需要指定每一个varchar的字节数。 DecimalField 是Python中十进制浮点数的实例。上述例子中含有两个参数，max_digits=表示数字位数，这是同时包含整数部分和小数部分的位数。decimal_places=表示小数位数。default=用于在使用UserInfo.objects.create()时没有指定account参数值的时候的默认值。 DateTimeField DateTimeField是专门存储时间的字段类型，格式为Y-m-d H:m:s。当我们要输出这个值时，我们通常要先对其进行格式化。我们使用strftime(&#123;format&#125;)来达到这个目的。format的格式包含以下多种选择。 12345678910111213141516171819202122%y 两位数的年份表示（00-99）%Y 四位数的年份表示（000-9999）%m 月份（01-12）%d 月内中的一天（0-31）%H 24小时制小时数（0-23）%I 12小时制小时数（01-12）%M 分钟数（00=59）%S 秒（00-59）%a 本地简化星期名称%A 本地完整星期名称%b 本地简化的月份名称%B 本地完整的月份名称%c 本地相应的日期表示和时间表示%j 年内的一天（001-366）%p 本地A.M.或P.M.的等价符%U 一年中的星期数（00-53）星期天为星期的开始%w 星期（0-6），星期天为星期的开始%W 一年中的星期数（00-53）星期一为星期的开始%x 本地相应的日期表示%X 本地相应的时间表示%Z 当前时区的名称%% %号本身 当然，我们最常用的还是 12time.strftime(&quot;%Y-%m-%d %H:%m:%s&quot;) # 精确到秒的时间记录time.strftime(&quot;%Y-%m-%d&quot;) # 精确到日期的时间记录 在Django模板语法中，一般是不允许出现括号的。在前端页面，我们需要改写成 1&lt;span&gt;&#123;&#123; time|date:&quot;Y-m-d&quot; &#125;&#125;&lt;/span&gt; 在Pycharm中按住Ctrl查看上述案例中date的源码，可以发现其也是一个函数，只不过使用了特殊的|符号表示而已。 ForeignKey ForeignKey表示的是外键，也就是将表与表之间建立联系的一种方式。在上述案例中，由于我们需要知晓员工的所属部门，因此我们使用外键将depart字段与Department中的id字段相关联。在Django自动生成表的时候，depart字段会被命名成depart_id。使用ForeignKey的时候，我们需要指定参数to=和to_field=，前者指定与哪张表关联，后者指定关联的字段名。当然了，由于关联的原因，我们还需要指定on_delete=，这个参数指定当Department表中的数据删除时，UserInfo中对应这些数据的记录将要如何操作。models.CASCADE表示级联删除，即删除所有与被删除数据相关联的记录；还可以选择models.SET_NULL，这样所有关联数据的该字段将会被置空。但这有一个前提，你需要在参数列表指定该字段可以为空，即 1department = models.ForeignKey(to=&quot;Department&quot;, to_field=&quot;id&quot;, null=True, blank=True, on_delete=models.SET_NULL) 在读取数据中，我们需要先获取UserInfo的记录，再通过外链访问Department，即 123456obj = models.UserInfo.objects.fileter(&#123;筛选条件&#125;).first() # 获取满足筛选条件的第一个对象print(obj.depart_id) # 访问obj.depart_id，我们得到的是部门idtitle = models.Department.objects.filter(id=obj.depart_id).first().title # 再次筛选，取出title字段才是我们要的部门名称title = models.Department.objects.filter(id=models.UserInfo.objects.filter(&#123;筛选条件&#125;).first().depart_id).first().title# 合并上述语句我们得到非常之长的一句数据库查询语句 显然，这句语句太长了，Django提供了另一种通过外键查询另一张表的方式，在上述例子中 12obj = models.UserInfo.objects.fileter(&#123;筛选条件&#125;).first() # 获取满足筛选条件的第一个对象print(obj.depart.title) # 这时直接输出了部门名字 在这种书写方式下，obj.depart直接返回根据depart_id查询到的第一个object。由于我们这个案例中ID值唯一，于是直接访问其.title即可。 于是在前端页面，我们可以通过如下的模板语法访问每一个人对应的部门的名称： 12345678&lt;tbody&gt;&#123;% for obj in userinfo_list %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; obj.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; obj.depart.title &#125;&#125;&lt;/td&gt; &lt;/tr&gt;&#123;% endfor %&#125;&lt;/tbody&gt; SmallIntegerField 该数据类型常应用于固定的枚举型，例如上例中的性别。在绝大多数情况下，性别是不会继续添加的，因此我们可以用元组的嵌套来指定这种对应关系： 1234gender_choices=( (1, &quot;男&quot;), (2, &quot;女&quot;)) 相比于存储汉字，在数据库中存储短整型占用更少的存储空间。这种情况下，你需要为SmallIntegerField指定参数choices=。这个参数接受一个嵌套元组用来指定对应关系。 当然，这会带来一个问题，我们访问obj.gender时，会输出整型而非我们想要的汉字“男”或“女”，同样的，Django提供了一个函数： 1234obj.get_gender_display() # 这个函数名称会随着你对字段名命名的不同而变化# 命名规则obj.get_&#123;字段名称&#125;_display() 在前端页面，你可以使用模板语法来完成这个功能： 1&#123;&#123; obj.get_gender_display &#125;&#125; 需要注意的是：你依然不需要在函数末尾添加括号。 Django的html模板 这部分不是本文的重点，但也是Django开发中十分重要的一部分，其可以大大增加代码复用率。因此也一并写在这里。 很多时候，许多HTML文件都具备一部分的相同结构，例如，所有页面都有页面顶部的导航栏(navigation bar)，都需要引入相同的css和js等文件。Django提供模板页面来解决这个问题。我们只需要在模板文件中需要被插入的结构加入： 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;!--省略以上html内容--&gt; &#123;% block &#123;板块名称&#125; %&#125; &#123;% endblock %&#125; &lt;!--省略以下html内容--&gt;&lt;/html&gt; 然后再需要使用的页面引入该模板即可，如果模板名称为layout.html，那么就可以写成这样： 123456&#123;% extends &#x27;layout.html&#x27; %&#125;&#123;% block &#123;模块名称&#125; %&#125;&lt;!--这里是你的html--&gt;&#123;% endblock %&#125; 渲染该页面时，Django会自动将其与模板layout.html拼接。一个模板中可以有多个这样的结构，一个HTML文件中也可以由多个这样的结构组成。 后记 这篇文章字不多，但干货占比也挺高的。赶紧写出来也是方便我后续复习和查询使用。所以就浅浅地日更了一下。那这篇文章就到此结束吧！该休息咯。","tags":["python","django"],"categories":["学习笔记"]},{"title":"django学习笔记(2)：操作MySQL数据库","path":"/posts/a907f775/","content":"使用django操作mysql数据库。 前言 数据库是web应用中很重要的组成部分之一。Django框架自带了sqlite3数据库，然而在使用的广泛程度上，MySQL的应用场景更加多。本篇主要解释如何将数据库换成MySQL，以及一些基本用法。 更换默认数据库为MySQL 创建数据库 由于django的orm只能完成对于表的操作，因此数据库的创建需要我们自行完成，这里以本地MySQL数据库为例。在MySQL终端输入 完成数据库的创建。然后运行 use &#123;db_name&#125; ，若提示为empty set（空的数据库），则创建成功。 安装第三方依赖 首先我们需要安装第三方包 pymysql （你也可以使用mysqlclient），这个第三方包能够帮助Django完成对MySQL数据库的增删改查操作， 如果安装缓慢，可以参考本系列的第一篇文章，将安装源换成国内镜像站。 更改项目配置文件 在项目目录下找到setting.py，找到DATABASES，这里默认是 123456DATABASES = &#123; &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27;: &#x27;django.db.backends.sqlite3&#x27;, &#x27;NAME&#x27;: BASE_DIR / &#x27;db.sqlite3&#x27;, &#125;&#125; 其中， ENGINE 指明了数据库类型， NAME 指明了数据库名称。默认情况下，Django使用内部集成的sqlite3.我们修改之， 12345678910DATABASES = &#123; &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;, &#x27;NAME&#x27;: &#x27;webapp&#x27;, # 数据库名字 &#x27;USER&#x27;: &#x27;root&#x27;, &#x27;PASSWORD&#x27;: &#x27;&#123;你的密码&#125;&#x27;, &#x27;HOST&#x27;: &#x27;127.0.0.1&#x27;, # MySQL在哪个ip &#x27;PORT&#x27;: &#x27;3306&#x27;, # 端口号 &#125;&#125; 其中，HOST是主机ip，这里使用的是本地，因此是127.0.0.1，PORT是端口号，本地MySQL的端口号是3306。然后，你需要在项目的_init_.py中添加： 123import pymysqlpymysql.install_as_MySQLdb() 使用Django操作MySQL的表 创建表 表的操作都可以用python语法完成，其中orm会将其翻译成SQL语句，对于我们来说，无需自己再写SQL语句了。 在已注册的应用下的models.py中新建类，例如我们要创建一个用户信息的表，那么我们可以写成 123456from django.db import modelsclass UserInfo(models.Model): name = models.CharField(max_length=32) password = models.CharField(max_length=64) age = models.IntegerField(default=0) 然后，我们在终端运行 这时，Django自动为我们创建了表，其相当于 123456create table app01_userinfo( id bigint auto_increment primary key, name varchar(32), password varchar(64), age int) 在MySQL终端输入 终端输出 1234567891011121314151617mysql&gt; show tables;+----------------------------+| Tables_in_webapp |+----------------------------+| app01_userinfo || auth_group || auth_group_permissions || auth_permission || auth_user || auth_user_groups || auth_user_user_permissions || django_admin_log || django_content_type || django_migrations || django_session |+----------------------------+11 rows in set (0.00 sec) 这表明，app01_userinfo的表已经被创建。当然，这里其他的表示Django内部的其他类，我们这里无需在意。接下来我们检查字段。MySQL终端输入 观察到输出 12345678910mysql&gt; desc app01_userinfo;+----------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+----------------+| id | bigint | NO | PRI | NULL | auto_increment || name | varchar(32) | NO | | NULL | || password | varchar(64) | NO | | NULL | || age | int | NO | | NULL | |+----------+-------------+------+-----+---------+----------------+4 rows in set (0.00 sec) 其中，name，password和age都是我们所定义的字段，id是Django自动创建的字段。 修改表 当然，我们也免不了修改表的字段数，例如，我们不需要age这一个字段了，我们只需要在models.py下删除之。 123456from django.db import modelsclass UserInfo(models.Model): name = models.CharField(max_length=32) password = models.CharField(max_length=64)- age = models.IntegerField(default=0) 然后重新在终端执行makemigrations和migrate二连，我们就可以观察到这一字段消失了。 有时候，我们也会为表中新增字段，例如： 1234567from django.db import modelsclass UserInfo(models.Model): name = models.CharField(max_length=32) password = models.CharField(max_length=64) age = models.IntegerField(default=0)+ sex = models.CharField(max_length=4) 执行数据迁移二连，我们会发现控制台有警报。 控制台警报 这是因为，当我们添加字段时，如果表中有数据，那么这些数据的新字段的值我们就不得而知。因此，会产生上述的告警。控制台给了我们两种解决方式： 为已有的数据分配初始值来填补这些空缺； 在models.py中声明初始值。 对于选择1，我们可以将已有的数据的该字段的值赋值成为我们指定的值，这里不多说了。对于选择2，则需要为该字段指定默认值，那么上述语句可以被重写成 123456class UserInfo(models.Model): name = models.CharField(max_length=32) password = models.CharField(max_length=64) age = models.IntegerField(default=0)- sex = models.CharField(max_length=4)+ sex = models.CharField(max_length=4, default=&#x27;male&#x27;) 于是，控制台告警消失，并且之前所有已存在的数据的新字段都被赋值为初始值。当然了，你也可以声明该字段允许为空，例如： 123456class UserInfo(models.Model): name = models.CharField(max_length=32) password = models.CharField(max_length=64) age = models.IntegerField(default=0)- sex = models.CharField(max_length=4, default=&#x27;male&#x27;)+ sex = models.CharField(max_length=4,blank=True,null=True) 这样也是可以的。 使用Django操作MySQL中的数据 我们依然可以用python语句来操作MySQL中的数据。 创建数据 创建数据的语法是： 1&#123;类名&#125;.objects.create(参数列表) 例如我们需要在app01_userinfo中插入一段记录，以下就是一个例子： 1UserInfo.objects.create(name=&quot;Felix&quot;, password=&quot;123&quot;, age=19) 这句python会被orm翻译成SQL语句： 1insert into app01_userinfo(name, password, age)value(&quot;Felix&quot;, &quot;123&quot;, 19) 删除数据 删除数据的语法是： 1&#123;类名&#125;.objects.filter(筛选条件).delete() 如果你要清空数据，那么可以写成 1&#123;类名&#125;.objects.all().delete() 当然，过滤函数还有许多写法，这里只展示了filter()和all()。 查找数据 查找数据的语法是 1&#123;类名&#125;.objects.filter(筛选条件) 函数的返回值是一个QuerySet类型，在python中，其可以被理解成结构体对象的列表，例如 [&lt;UserInfo: UserInfo object (1)&gt;, &lt;UserInfo: UserInfo object\r(2)&gt;, &lt;UserInfo: UserInfo object (3)&gt;] 如果我们要读取其内部值，就可以用简单的python语法实现，这里举个例子： 123user_info_list = UserInfo.objects.all()for obj in user_info_list: print(obj.id, obj.name, obj.password, obj.age) 当然，如果我们明确知道表中只有一行数据，那么我们可以避免使用循环，直接用 1obj = UserInfo.objects.all().first() 获取对象即可。 更新数据 更新数据，首先要找到需要更新的记录，因此，前一部分与查找是很相似的。update()函数完成后续的更新操作，例如： 1UserInfo.objects.filter(id=2).update(password = &quot;999&quot;) 则被筛选出的记录的password字段都会被更新成999。 后记 有了与数据库的联动操作，我们已经可以写一些基础的业务逻辑了。当然，Django对于数据库的操作远不止这些。","tags":["python","django"],"categories":["学习笔记"]},{"title":"django学习笔记(1)：Django的安装与准备","path":"/posts/357997ca/","content":"开一个新坑，django开发。 Django介绍 Django是一个开放源代码的Web应用框架，由Python写成。利用Django和相关的html和CSS知识，我们可以轻松构建出一个简单的网站。本文主要介绍使用Django的一些准备工作。 安装Django 首先，你需要Python环境。这里以Python3环境为例。安装有两种方式：命令行安装和使用开发软件Pycharm。 使用命令行Pycharm中使用 这里以Linux操作系统为例。首先打开命令行窗口，建立虚拟环境。 而后激活此虚拟环境。 如果想要停止此虚拟环境，你可以使用deactivate来关闭之。然后我们来下载Django。 注意 如果下载速度很慢，你可以尝试更换成国内镜像源。例如pip install Django -i https://pypi.tuna.tsinghua.edu.cn/simple+ 清华：https://pypi.tuna.tsinghua.edu.cn/simple +阿里云：http://mirrors.aliyun.com/pypi/simple/ + 中国科技大学https://pypi.mirrors.ustc.edu.cn/simple/ +华中理工大学：http://pypi.hustunique.com/ +山东理工大学：http://pypi.sdutlinux.org/ +豆瓣：http://pypi.douban.com/simple/ Pycharm中的使用相对而言简单许多。在项目文件下新建项目，而后在文件-&gt;设置-&gt;项目-&gt;Python解释器中安装Django即可。 开始使用Django 新建Django项目 下载完Django库后，我们需要在我们的项目文件夹中新建一个Django项目，这将告诉Django，这不是一个纯Python项目。首先我们在Pycharm的终端或者命令行窗口运行以下指令： 1django-admin startproject &lt;projectname&gt; . 其中，&lt;projectname&gt;是项目名称。 如果你使用的是PycharmProfessional\rEdition，那么你可以直接在创建项目之初就创建Django项目，而无需上述的多步操作。但需要注意，在项目的setting.py中TEMPLATES中第一个字典的键DIRS存在[os.path.join(BASE_DIR, templates)]，它将影响静态文件查找位置，最好删去。 注意，上述的命令语句千万不要忘记末尾的.。遗漏了这个句点将在后续项目部署上需要额外的复杂操作。 最后运行python manage.py runserver，检查Django是否能正确运行。若可以，则初步配置成功。 Django项目中的文件结构 123456789&lt;projectname&gt;├─manage.py 【项目管理、启动项目、创建应用、数据管理】【无需更改】│ └─&lt;projectname&gt; ├─__init__.py ├─settings.py 【项目配置文件】【例如注册应用、链接数据库】 ├─urls.py 【url和函数对应关系】【主要编写的部分】 ├─asgi.py 【接收网络请求】【无需更改】 └─vsgi.py 【接收网络请求】【无需更改】 新建应用 根据项目的业务逻辑，我们将其分为多个应用来分开管理。我们先新建第一个应用，在终端输入命令 1python manage.py startapp &lt;appname&gt; 于是我们得到这样的目录。 12345678910111213141516171819&lt;projectname&gt;├─manage.py 【项目管理、启动项目、创建应用、数据管理】【无需更改】│├─&lt;appname&gt;| ├─__init__.py| ├─admin.py 【后台管理界面】| ├─apps.py 【启动类】| ├─models.py 【在数据库中创建对应表】| ├─tests.py 【测试类】| ├─views.py 【函数】| └─migrations 【数据库迁移记录】| └─__init__.py| └─&lt;projectname&gt; ├─__init__.py ├─settings.py 【项目配置文件】【例如注册应用、链接数据库】 ├─urls.py 【url和函数对应关系】【主要编写的部分】 ├─asgi.py 【接收网络请求】【无需更改】 └─vsgi.py 【接收网络请求】【无需更改】 新建应用后，我们需要对其注册。我们找到应用下的apps.py，找到其启动类类名，以下是一个例子。 1234567# filename: apps.pyfrom django.apps import AppConfigclass App01Config(AppConfig): default_auto_field = &#x27;django.db.models.BigAutoField&#x27; name = &#x27;app01&#x27; 于是我们修改settings.py中的内容： 1234567891011# filename: settings.py# 省略INSTALLED_APPS = [ # 省略 &#x27;&lt;appname&gt;.apps.APP01Config&#x27;,]#省略 于是，新的应用已经注册完毕，我们可以在该应用上开发了。","tags":["python","django"],"categories":["学习笔记"]},{"title":"《Hollow Knight(空洞骑士)》简评","path":"/posts/957c52d5/","content":"这次打算写点不一样的，就来浅浅聊一下最近走完主线剧情的《Hollow Knight(空洞骑士)》吧。 前言 《空洞骑士》这款游戏其实一直存在于笔者的愿望单里，但是有好长一段时间也是仅仅存在于愿望单里而已。后来在室友的强烈推荐、并且Steam促销的双重驱动下，还是下载了这款游戏。6月份期末周一结束，便下定决心体验这款游戏。玩了40h也勉强算是通关了主线剧情。这里就简要地说一说自己想说的吧。 关于游戏 谈谈设计 BOSS设计 如果要简单地概括《空洞骑士》的游戏形式，我想“平台跳跃游戏”的标签就足够让大家知道其游玩形式了。此外，这款平台跳跃游戏还包含了“魂类游戏的要素”，简而言之，就是不低的死亡成本和难度较高的BOSS设计。其实玩家们都会知道一个说法：三螳螂是多少新手的噩梦。 新手劝退关：三螳螂之战 但其实，具有一定难度的BOSS设计也在很大程度上增加了游戏的可玩性。与其使用炫酷的特效和画面来告诉一个玩家你将面对的敌人有多么强大，倒不如直接让玩家体会被BOSS击败的无力感。 当然了，这也为游戏制作者带来了不少的挑战：难度如何把控？如何让每一个不同的BOSS都有其特色？这其实是不容易把握的。笔者曾经体验过《Sekiro: Shadows Die Twice(只狼：影逝二度)》这款游戏。虽然这部作品依然非常出色，但其实有部分BOSS（或者严谨的说，精英怪）的设计是有些重复的（比如蚺蛇重藏和牛饮德次郎，但也有人认为他们其实是一个人，这里就不展开讨论了）。但不得不说，《空洞骑士》的BOSS设计并不会让人觉得厌烦，面对新的BOSS，总有新的打法可以尝试。 下砸老师：粪虫防御者 黑冲老师：叛徒领主 操作设计 在玩家操作上，《空洞骑士》没有采用大量的按键、或者是游戏内技能选择来控制技能释放，所有的技能都可以通过少量键位完成释放。单纯攻击键，直接释放是平砍、与“上”键组合是上砍；与“下”组合是下劈(非常有技术含量的操作)；长按攻击键蓄力，通过独自释放、与上键组合、与下键组合完成三种不同的剑技；跳跃键按住时长控制跳跃幅度；长按施法是恢复等等。键位虽少，但是用好谈何容易。真正熟练之后，你会发现，看似不可能的道路可以通过下劈、二段跳、冲刺的组合轻松越过，竞技场的可以足不沾地与对手们进行空战等等。其实主角并没有飞行的能力，但又何尝不像在飞行。 竞技场空战：下劈、二段跳、螳螂抓钩的奇妙组合 谈谈剧情 故事发生在一个称为“圣巢”的底下虫子王国里。上古时期，圣巢被虚空之力所占领。在这里，虚空才是一切的主宰。后来，名为幅光的神驻留在此地，利用自身的光芒将虚空的黑暗逐步逼退，最后将其困于深渊之中。自此，幅光便是这个王国的唯一领袖，圣巢也在他的带领下逐渐繁荣昌盛。 幅光 但后来，一只名为沃姆的虫子路过此地，有了驻足此地的想法。沃姆与幅光对于圣巢的统治有着根本的不一致观点。幅光，主张思想上的统一，反对繁衍；而沃姆，却强调虫子的多样性。于是，沃姆和幅光的大战一触即发。但是，沃姆不敌幅光，在大战中败下阵来，就此死去。 但需要注意的是，在《空洞骑士》的世界观中，死亡并非消逝。所有的死亡，都会留下踪迹。沃姆也是这样。白王，就是沃姆死后的化身。 白王的遗迹 幅光自然无法接受自己被白王击败的结局，于是，幅光利用梦境释放瘟疫感染圣巢内的虫子。在瘟疫的感染下，虫子们完全丧失了自主意识，只能进行基本且简单的思考。繁荣的圣巢，一刹那间成了死寂的废墟。在这里，只有无意识的虫子和瘟疫。 但白王自然无法容忍这样事情的发生。他发现，圣巢内的蜂巢和螳螂村完全不受瘟疫感染。究其原因，是因为他们都有坚定的意志：蜂巢有自己的领袖信仰；而螳螂村，崇尚武力，他们的存在就是追求更高的荣耀。因此，他们不受瘟疫的感染。换句话说，只有真正的无意识或者坚定意志，才能免于幅光散播的瘟疫的感染。于是，容器就诞生了。 击败BOSS后鞠躬表示敬意 容器们的本体诞生于虚空，白色的头颅是容纳他们的虚空的自我的容器。他们源自虚空，所以完全没有个人的意志。他们的任务，就是对抗幅光的瘟疫，并永久地封印幅光，将圣巢变回原来的样子。但是，容器们并非都是可用的。容器必须没有自我意识，并且必须具有强大的能力。迈出深渊，就成为了容器们的第一道考验。深渊里，满是破碎的容器躯壳，他们都是白王失败的作品。但，有一个容器，成功通过了考验，迈出了深渊，完成了修炼。而他，就是纯粹容器，也叫空洞骑士 。 没有可以思考的心智 没有可以屈从的意志 没有为苦难而哭泣的声音 生于神与虚空之手 你必封印在众人梦中散布瘟疫的障目之光 你是容器 你是空洞骑士 空洞骑士承载着白王的愿望，将幅光封印在自己体内，从而阻止瘟疫的扩散。事实证明，他也成功了。瘟疫在圣巢渐渐散去，满是僵尸的圣巢，又渐渐开始恢复往日的荣光。为了保证彻底的封印，白王号召了三位守梦者来加固封印。作为代价，三位守梦者会陷入永久地沉睡。为了纪念他们，白王在泪城的不同地方建立了纪念碑。 纪念空洞骑士 守梦人纪念碑 但是，令白王没想到的是，纯粹容器并不纯粹。苦痛之路的尽头告诉我们，空洞骑士与白王的朝夕相处已经使得空洞骑士对白王产生了亲情。同时，空洞骑士在深渊的回头，也表示他对兄弟产生了情感。不纯粹的容器，势必要被幅光所感染。对于幅光而言，存在于梦境之中的他如果不被同族所记住，那他就与死亡无异。幅光渐渐感染空洞骑士，挣脱了束缚，又重新向圣巢散播了瘟疫。而这次，设法从深渊逃离的小骑士感受到了同类的召唤，回到了圣巢。 小骑士在圣巢的探索中，一步步揭开王国的过去，直面自己空虚的内在，背负起重建圣巢的责任。 当然，游戏也有多个结局。其中一个便是小骑士击倒先辈(空洞骑士)，进入梦境，直面幅光。这是小骑士第二次庄严拔刀，也是最后一次。击败幅光后，小骑士会舍弃自己的容器，将自己的虚空之躯暴露在外，在前辈的配合之下击杀幅光。 击败幅光 从此，瘟疫散去，但圣巢也不如从前。封印幅光的黑巢中剩下的，只有小骑士残破的外壳。而小骑士完成了自己的实名，重新回到深渊的虚空之中。 整个游戏其实蛮黑暗的。不论是结束后的音乐画面，还是黑暗战胜光芒的主线剧情(当然这里的光芒才是反派)，又或是小骑士和其他大部分NPC的结局，都让人觉得遗憾。在这个游戏中，满是衰落王国的萧瑟和主角的自我牺牲。游戏的最后，白宫依然只存在于守卫的梦境之中，鹿角站铃铛也不会再热闹起来，深渊的一切也回归虚空，蓝湖边只剩下一把骨钉... 后记 其实我的文笔也蛮烂的，也第一次整理剧情和时间线。希望大家可以多提提意见什么的。写这篇文章也主要是记录一点自己的感受，毕竟到现在想起这段故事还会觉得可惜和遗憾。但是这个游戏真的太优秀了！我真的强推。最后的最后还想和大家分享几个我喜欢的BGM！绝对入股不亏！","tags":["游戏","空洞骑士"],"categories":["游戏"]},{"title":"6月24日","path":"/posts/b56d6855/","content":"随便写写。 写点东西，或许以后会放出来 上个学期，大概是三月份的时候，无比期待着转专业。当时对于转专业的热情似乎有些太上头，以至于有一段时间满脑子都是转专业，甚至连上课都会思绪飘走。到了四月中旬，知道不能在平台内转专业后，便想着要不要去安泰。说实话，我当时发现自己下意识有了这个想法以后，就觉得自己可能不是那么想学某一专业，我可能更加是在找寻一种逃离。当时和另外一个朋友说了这个想法，确信了自己似乎在转专业这件事上走错了路，目的似乎已经改变了。于是，经过内心的斗争，还是放弃了四月份的自主转专业。（其实说实在话，也有一部分原因是害怕自己下半学期太摆，导致学积分疯狂后退，便想着赶紧趁着优势润了） 其实说实话，我很喜欢生医工的氛围。疫情期间更让我看清楚生医工拥有大院所比拟不了的人文关怀。这点其实很显然，我想不管是谁都能感觉出来。因为这个其实也有点动摇到我的转专业决心了，虽然不是主要原因。但我想过，如果我在大院，可能并不会有老师那么关注我，也不会在被转运的时候有学院领导来慰问我，也不会有班主任打电话了解学习状况，更不会有刚步入学生会就能参加很多重要活动的核心策划。我得到的许多我认为很重要的东西，其实并不是我能力多么强，纯粹是因为学院规模小，给予了我更多的机会而已。我害怕转专业后，来到陌生的环境，可能再也得不到生医工给我的归属感。 最近可以说是我转专业热情消退的最严重的一段时间了。我退出了夏季学期选的NIS的课程，也对当初满怀希望报名的PRP丧失信心。因为我无法在这两门课中找到充足的动力去学习它们。原因或许只是因为我对它们不感兴趣，但也未必那么简单。可能是经历了一学期的神经紧绷，拼命追求一个不错的绩点后的精疲力竭；也能是PRP的能力要求对我来说确实为时尚早；也可能是NIS的那门课的设计确实让人难以产生兴趣。如果是这两种，那还好，至少不是我对信安专业知识的麻木，但如果是第一种，那是否意味着，在体验信安的学习过后，我已经提不起兴趣了呢？这种无法将问题正确归因的状态导致我这两天都无所事事。于是，加上三四月份的内心挣扎，我会质问我自己：我真的想转专业吗？还是纯粹是一种突发的错觉？ 但是时间不等人。大二的上学期，我需要同时决定转不转专业、是否辅修；如果是，如何安排这两件事？我需要利用时间搜集资源和信息，但是暑假，我还有其他任务在身，并且，好好地休息。这太难以决定了。我发现上大学后，需要自己决定并且承受后果的事情太多了，而且这些事情往往只有一次机会，错过就不再来。如果用两个词形容我现在的处境，就是犹豫和纠结。 最近把关于我页面的内容也做了一些修改，是因为我现在也不了解自己的想法。等到什么时候想明白了，再好好写吧。","tags":["碎碎念"],"categories":["碎碎念"]},{"title":"Python学习笔记：列表和字典","path":"/posts/fe46061e/","content":"作者序 学习一门编程语言，语法是最基础的。但是学习语法往往不是那么困难，因此，写一篇语法笔记似乎显得不是那么有必要。事实正如此，对于Python中的循环、判断等语句，我并没有整理的意图，因为我觉得太过多余，即使可以玩的很花。但是对于列表和字典这一章内容，其重要之处或许不在于其语法有多难，而是其体现了一些数据结构的思想。在C++中，线性表与这里的列表；查找表与这里的字典，都有着一些奇妙的联系。而因为Python很好的隐藏了一些底层实现，若不注意细节而使用这些内置函数和方法，是极有可能出错的。因此，本文将这些内容记录下来，既可以作为初学者的参考，又可以作为我的笔记以待后续查阅。 正文 列表 什么是列表 Python中的列表是一系列特定元素按特定顺序构成的集合，这和C++中数组十分相似。对于列表，我们通常用[]来声明一个变量储存一个列表，例如 12bicycles = [&#x27;trek&#x27;, &#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;] #初始化结束的列表empty = [] #声明一个空列表 访问列表元素 和C++相类似的，Python支持根据元素下标来访问元素。例如对于上面的bicycles列表，我们可以用bicycles[0]来访问元素'trek'。当然了，Python支持使用负数索引来访问列表元素，例如访问上面列表中的'specialized'，我们除了使用bicycles[3]，还可以使用bicycles[-1]来访问这个元素。对于长度未知的列表，我们可以用这个方式来访问末尾的几个元素。 列表元素的修改、添加和删除 既然我们说列表是一种线性表，那么其需要能够支持线性表的基本操作。Python内置了丰富的函数和方法支持我们做到这些操作，下面逐一介绍之。 修改元素 对于修改元素，我们可以直接指定列表元素下标修改之，例如 1bicycles[0] = &#x27;ducati&#x27; 这样，我们就将列表中原本的'trek'元素修改成了我们指定的'ducati'元素。 插入元素 对于插入元素，Python提供了两种方法，分别是insert()和append()。对于前者支持在指定位置插入元素，而后者是将元素插入到列表尾，例如下面代码： 123456bicycles = [&#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;]print(bicycles)bicycles.append(&#x27;ducati&#x27;)print(bicycles)bicycles.insert(2, &#x27;trek&#x27;)print(bicycles) 则对应的程序输出为 123[&#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;][&#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;, &#x27;ducati&#x27;][&#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;trek&#x27;, &#x27;specialized&#x27;, &#x27;ducati&#x27;] 删除元素 对于删除元素，一般有三种方法：del语句，pop()方法和remove()方法。 对于del语句，你只需要指定删除的元素即可，例如 1del bicycles[0] 就是删除bicycles中的第一个元素。 对于pop()方法，一般由两种使用方式：无参数和指定元素下标。对于无参数的pop()方法，会删除当前列表中的最后一个元素。这种模式下的pop()方法和之前提到过的append()方法可以天然的实现一个栈。或者，你也可以指定pop()的参数，例如bicycles.pop(1)，则其中的'redline'元素就会被移出列表。pop()方法具有返回值，返回值是被删除的元素。 对于remove()方法，是查找列表中第一个和指定参数相同的值，将其删去。注意，由于只删除第一个查找到的值，因而如果我们要将指定参数的值都删去，需要使用循环，例如 1234languages = [&#x27;cpp&#x27;, &#x27;python&#x27;, &#x27;c&#x27;, &#x27;go&#x27;, &#x27;python&#x27;, &#x27;html&#x27;]while &#x27;python&#x27; in languages: languages.remove(&#x27;python&#x27;)print(languages) 这种方式下，可以将列表中的所有指定元素都删除。 组织列表 除了基本的增删改查，我们对于列表还需要一些操作，这种操作不更改列表元素值，但是会更改元素之间的顺序。很便于使用的，Python依然为我们内置了强大的函数和方法来实现这些功能。 函数名 解释 用法示例 sort()方法 对列表永久非减（或非增）排列 bicycles.sort()或者bicycles.sort(reverse = True) sorted()函数 对列表临时非减（或非增）排列 sorted(bicycles)或者sorted(bicycles, reverse = True) reverse()方法 列表逆置 bicycles.reverse() len()函数 列表求长 len(bicycles) example[:] 列表切片 bicycles[0:3] 注意，复制列表时，注意一下两种方式的区别： 123foods1 = [&#x27;apple&#x27;, &#x27;pizza&#x27;, &#x27;hamburger&#x27;]foods1 = foods2 #这种复制是错误的foods1 = foods2[:] #利用列表切片的方式复制 第一种复制的结果是使得foods1和foods2指向了同一个列表，使得在更改foods1的列表元素时，foods2也会一同改变。而后者是两个互不干涉的、独立的列表。 字典 Python中，字典是若干组键-值对的集合，其一般形式如下： 12345target = &#123; &#x27;color&#x27;: &#x27;blue&#x27;, &#x27;points&#x27;: 5, &#x27;speed&#x27;: &#x27;fast&#x27;,&#125; 通过构建这样的键值对，我们可以通过键来访问其对应的值，有点类似于自定义下标的数组。上面示例中的target，就是我们说的字典。 访问字典的值 如同上面所说，我们完全可以把其当成数组来用。如果我们要知道target的color信息，我们可以通过下面的代码输出它： 1print(target[&#x27;color&#x27;]) 这时控制台输出blue。 添加或修改键值对 这两点放在一起讲的原因是，两者的语法是相同的。请读者参见以下代码： 12target[&#x27;color&#x27;] = &#x27;red&#x27; #1target[&#x27;x_position&#x27;] = 4 #2 对于第一条语句，首先在字典target中寻找关键字'color'，由于找到的缘故，将其对应的值覆写为'red'。对于第二条语句，由于无法在字典中查询到'x_position'的任何记录，因而新建了一对键值关系，并将其插入了字典中。 删除键值对 同样的，del语句给我们提供了删除键值对的方法。如果我们需要删除有关位置的信息，我们只需要del target['x_position']语句即可。 遍历键值对 如果我们想遍历键值对，可以使用的最简单的语句是： 12for key, value in target.items(): print(key + &quot; &quot; + value) 上述语句将字典中的每一个键值对，都分别把键、值赋值给了key和value。当然了，这时的输出顺序未必按照我们定义的一般按顺序输出，原因是字典只保证键值对的一一对应关系，而不在意互相之间的顺序问题。因此，要按照顺序遍历字典，我们需要使用其他的方式， 对于字典，Python内置了两种方法：keys()方法和values()方法。两者返回的都是列表，前者是键组成的列表，后者是值组成的列表。相信到这里，你已经有思路如果按照顺序遍历字典了，这里给出一种方式： 12345678favorite_language = &#123; &#x27;jen&#x27;: &#x27;python&#x27;, &#x27;sarah&#x27;: &#x27;c&#x27;, &#x27;edward&#x27;: &#x27;ruby&#x27;, &#x27;phli&#x27;: &#x27;python&#x27;,&#125;for person in sorted(favorite_language.keys()): print(person.title() + &quot;&#x27;s favorite language is &quot; + favorite_language[person].title() + &quot;.&quot;) 上面的程序输出结果是 1234Edward&#x27;s favorite language is Ruby.Jen&#x27;s favorite language is Python.Phli&#x27;s favorite language is Python.Sarah&#x27;s favorite language is C. 由此，我们做到了按照我们所想遍历字典。 尾声 读者可以看到，Python中的列表和字典，其实已经包含了很多数据结构的东西，并且都给我们准备了不错的函数和方法。巧妙的是，这两个结构都可以自我嵌套，甚至互相嵌套，功能可以说已经非常强大了。因此，就像学习C++时刚接触到的函数一样，列表和字典也是水很深的内容之一。随着我的了解不断深入，我也会不断更新这篇文章。基础部分，就到此为止了。","tags":["Python"],"categories":["学习笔记"]},{"title":"数据结构试题分析","path":"/posts/528509f9/","content":"作者序 题目均来自于往年试卷，给出的代码都能够编译通过。 例题一：哈希表的使用 题面： 假设线性表采用顺序存储结构，试实现函数int DelRepeat()，用以删除所有重复元素，并返回删除元素的个数。要求算法的时间复杂度为\\(O(n)\\)。线性表结构定义如下： 1234567891011class seqList&#123; private: int* data;//保存的元素数组 int currentLength;//元素个数 int noData;//数据中不存在的元素 public: int DelRepeat()&#123; //add your code here &#125;&#125;; 代码实现如下，注意：测试代码未给出，请读者自行构造。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class seqList&#123; private: int* data;//保存的元素数组 int currentLength;//元素个数 int noData;//数据中不存在的元素 public: seqList(int n)&#123;//构造函数 currentLength=n;//元素个数 data=new int[n]; cout&lt;&lt;&quot;input data:&quot;&lt;&lt;endl; for(int i=0;i&lt;n;++i)&#123;//获取元素值 cin&gt;&gt;data[i]; &#125; &#125; void display()&#123;//展示数组元素 cout&lt;&lt;&quot;the data are:&quot;&lt;&lt;endl; for(int i=0;i&lt;currentLength;++i)&#123; cout&lt;&lt;data[i]&lt;&lt;&quot;\\t&quot;; &#125; cout&lt;&lt;endl; &#125; int delRepeat(int n)&#123;//删除重复元素 noData=n;//标记输入数据中不存在的元素 bool* status=new bool[currentLength]; for(int i=0;i&lt;currentLength;++i)&#123;//创建判断元素，为真则该位置的数字出现过 status[i]=false; &#125; int* hashtable=new int[2*currentLength];//创建哈希表 for(int i=0;i&lt;2*currentLength;++i)&#123;//哈希表初始化 hashtable[i]=noData; &#125; for(int i=0;i&lt;currentLength;++i)&#123; int pos=data[i]%(2*currentLength);//获得哈希值 while(hashtable[pos]!=noData&amp;&amp;hashtable[pos]!=data[i]) (++pos)%(2*currentLength);//定位到第一个可以插入的位置 if(hashtable[pos]==data[i])&#123; status[i]=true;//如果有该元素，标记为待删除元素 &#125; else&#123; hashtable[pos]=data[i];//没有该元素，插入该元素 &#125; &#125;//end for int i=0,j=0; int newLength=0; int oldLength=currentLength; int* tmp=new int[currentLength];//装载没被删去的元素 for(int i=0;i&lt;currentLength;++i)&#123; if(!status[i])&#123;//如果判断数组对应位置为假，保留该数字 tmp[j]=data[i]; ++j; newLength++; &#125; &#125; delete[] data;//内存管理 data=tmp;//数据内容更新 delete[] hashtable; currentLength=newLength;//更新数组长度 return (oldLength-currentLength); &#125;&#125;; 总结： 对于需要反复回溯已遍历元素中某个元素出现与否的，哈希表是一个很好的解决方式，可以减少\\(O(n)\\)的算法复杂度。注意哈希表的重点：哈希函数和冲突解决。 例题二：二叉树 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。请完善下列算法，实现将上述两个二叉树合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。注意：合并后的二叉树中结点允许直接使用这两个二叉树上的结点。给出二叉树的定义： 12345678910111213141516171819class binaryTree&#123; private: struct node&#123;//二叉树的节点类 int value; node* left; node* right; node(int val)&#123;//构造函数 value=val; left=NULL; right=NULL; &#125; &#125;; node* root;//二叉树的根节点 public: node* mergeTrees(node* t1, node* t2)&#123;//合并二树 //add your code here &#125;&#125;; 想法是：合并二树可以看成三个过程：合并根节点、递归调用合并左右子树。因此，合并二树的操作并不难，只需要注意递归跳出的条件：其中一棵树为空树即可。为了完成代码的检查，我们还需要复习一遍二叉树的构建和层次遍历的知识点。以下代码包含了测试代码，可以直接运行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;class binaryTree&#123; private: struct node&#123;//二叉树的节点类 int value; node* left; node* right; node(int val)&#123;//构造函数 value=val; left=NULL; right=NULL; &#125; &#125;; node* root;//二叉树的根节点 public: binaryTree()&#123;//基于层次遍历的构造函数 int val; int lval; int rval; cout&lt;&lt;&quot;input the root:&quot;; cin&gt;&gt;val; cout&lt;&lt;endl; root=new node(val); queue&lt;node*&gt; que1; que1.push(root); while(!que1.empty())&#123; node* tmp=que1.front(); que1.pop(); cout&lt;&lt;&quot;input the two children of the given node &quot;&lt;&lt;tmp-&gt;value&lt;&lt;&quot;:&quot;; cin&gt;&gt;lval&gt;&gt;rval; cout&lt;&lt;endl; if(lval)&#123; tmp-&gt;left=new node(lval); que1.push(tmp-&gt;left); &#125; if(rval)&#123; tmp-&gt;right=new node(rval); que1.push(tmp-&gt;right); &#125; &#125; cout&lt;&lt;&quot;binarytree has been built!&quot;&lt;&lt;endl; &#125; binaryTree(node* r)&#123;//给定根节点的构造函数 root=r; &#125; void display()&#123;//层次遍历 queue&lt;node&gt; que1; que1.push(*root); while(!que1.empty())&#123; node tmp=que1.front(); que1.pop(); cout&lt;&lt;tmp.value&lt;&lt;&quot; &quot;; if(tmp.left)&#123; que1.push(*(tmp.left)); &#125; if(tmp.right)&#123; que1.push(*(tmp.right)); &#125; &#125; cout&lt;&lt;&quot;display completed!&quot;&lt;&lt;endl; &#125; node* findRoot()&#123;//返回二叉树根节点的位置 return root; &#125; node* mergeTrees(node* t1, node* t2)&#123;//合并二树 if(!t1) return t2;//递归跳出条件，即其中一棵树是空树 if(!t2) return t1; node* t3=new node(t1-&gt;value+t2-&gt;value); t3-&gt;left=mergeTrees(t1-&gt;left,t2-&gt;left);//假定该函数能够完成合并二树的操作，只需要对左右子树递归调用 t3-&gt;right=mergeTrees(t1-&gt;right,t2-&gt;right); return t3; &#125;&#125;;int main()&#123; binaryTree tree1; tree1.display(); binaryTree tree2; tree2.display();//构建两棵树并展示之 binaryTree tree3(tree1.mergeTrees(tree1.findRoot(),tree2.findRoot()));//合并子树 tree3.display(); return 0;&#125; 例题三：拓扑排序 题面： 学生需要修读完所有的课程才能毕业，这些课程之间有先导关系（比如要修读数据结构，必须先修读程序设计思想方法）。假设任意一门课程可以在任何一个学期给满足条件的学生选修，且学生每个学期可以选修的课程数不限。先给出一些课程与课程之间的关系，求能够修完所有课程的最少学期数。 输入格式： 第1行：n m //正整数n ，代表课程的数量。非负整数m代表要给出几个先导关系。第2行到第1+m行: a b //每行两个整数：代表要选修编号为a的课程，必须先修读编号为b的课程。 输出格式： 一个整数，即修完所有课程的最少学期数。 思路： 本题可以参考拓扑排序的方式，即：选取入度为零的点，将其移除，然后更新有向图；再移除入度为零的点，如此循环。实现的代码如下，主函数也已经给出，且能够编译通过。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;class adjListGraph&#123; private: struct edgeNode&#123; int end; edgeNode* next; edgeNode(int e,edgeNode* n=NULL)&#123; end=e; next=n; &#125; &#125;; struct verNode&#123; int ver; edgeNode* head; verNode(int val=0)&#123; ver=val; head=NULL; &#125; &#125;; verNode* verList; int Vers; int* inDegree;//入度统计数组 public: adjListGraph(int vSize)&#123;//构造函数 Vers=vSize; verList=new verNode[Vers+1]; inDegree=new int[Vers+1]; for(int i=1;i&lt;=Vers;++i)&#123; verList[i].ver=i; inDegree[i]=0; &#125; &#125; void insert(int end,int in)&#123; verList[in].head=new edgeNode(end,verList[in].head); inDegree[end]++;//入度增加 &#125; int topSort()&#123; int counter=0; int remain=Vers;//剩余未被删除的元素个数，用于判断循环结束 int current;//当前将要出队的元素 queue&lt;verNode&gt; que1; while(remain!=0)&#123; for(int i=1;i&lt;=Vers;++i)&#123; if(inDegree[i]==0)&#123; que1.push(verList[i]);//入度为零的点入队 &#125; &#125;//end for while(!que1.empty())&#123; current=que1.front().ver; que1.pop(); edgeNode*p=verList[current].head; while(p)&#123; inDegree[p-&gt;end]--;//该出队元素所指向的元素入度自减 p=p-&gt;next; &#125; remain--; inDegree[current]=-1;//已修完的课在下一次循环不需要被读取 &#125; counter++;//完成后计数器增加 &#125; return counter; &#125;&#125;;int main()&#123; int n,m;//课程数量、先导关系 cin&gt;&gt;n&gt;&gt;m; adjListGraph graph(n); for(int i=1;i&lt;=m;++i)&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; graph.insert(a,b); &#125; cout&lt;&lt;graph.topSort()&lt;&lt;endl; return 0;&#125; 上述程序中指定队列的原因是，为了区分出每一学期修了多少门课。每一个学期进行一次统一的入队操作，而后出队直至队空为止。","tags":["数据结构"],"categories":["学习笔记"]},{"title":"DES加密算法","path":"/posts/e407c7d6/","content":"DES加密算法是目前使用最广泛的对称加密算法。它体现了对称加密算法中最经典的Feistel结构。尽管DES加密算法注定要为新的加密标准让出位置，但依旧是我们深入理解对称加密的最好的例子。 Feistel结构设计 流密码与分组密码 在最开始，我们有必要了解一下流密码和分组密码。对于明文\\(m\\)，我们有两种加密方式，一种是逐位加密，我们称这种加密方式为流密码；另一种方式是按照一定的长度作为一组一同加密，这样的加密方式称为分组密码。流密码的典型例子是凯撒密码，它就是对明文逐位加密的。相较于流密码，我们实际应用中更偏向于使用分组密码，因为流密码有一个缺陷：如果密钥长度不足，那么字符的统计规律就难以被隐藏，很容易受到基于统计的攻击。分组密码在一定程度上会更多地抹去统计信息，因此也就显得更安全。我们主要讨论分组密码。 Feistel密码结构的设计动机 我们不妨假设分组密码作用在长度为\\(n\\)的明文分组上，相应地，我们得到相同长度的密文。我们假设明文信息流是二进制流，那么长度为\\(n\\)的分组至多有\\(2^n\\)中情况。考虑到我们需要从密文复原到明文，因此，我们选择的分组替代方式应该是单射的。我们称这样的变换为可逆变换，也叫非奇异变换。上述例子中，非奇异变换一共有\\(2^n!\\)种 （注：对于第一个分组，我们可以从\\(2^n\\)中选取一个映射；对于第二个，有\\(2^n-1\\)种；以此类推）。这种加密方式下，映射表格就是密钥。这样看来，我们具有很大的密钥空间，任意一种分组情况选取的映射是任意的。我们称这种加解密映射为任意可逆变换。Feistel称这种密码为理想分组密码，因为它允许生成最大数量的加密映射来映射明文分组。 然而，这种方法是难以应用的。如果我们分组的\\(n\\)的值不够大（例如4），那它就和流密码没什么区别，非常容易基于统计规律被攻破；那\\(n\\)很大的情况呢？统计规律固然被隐藏了，但是我们提过一句话：映射表格就是我们的密钥。对于分组长度为\\(n\\)的任意可逆变换，其每种映射需要\\(n\\)位表示（即分组长度），并且我们有\\(2^n\\)中不同分组情况，因此，密钥长度可以表示为 \\[ L(n)=n\\cdot 2^n. \\] 指数级的增长是十分恐怖的。今天的密钥长度一般不少于64位，如果我们令上式中的\\(n=64\\)，其结果是\\(10^{21}\\)位！这个长度是不可接受的。因此，Feistel指出，我们只需要一种对任意可逆变换的近似。一般我们认为密钥空间是上面所提到的\\(2^n!\\)中的一个子集。于是，我们依靠什么标准来选取这个密钥空间使得其在降低密钥空间大小的情况下依然能保持足够的安全呢？ Feistel的设想 Feistel提出了一种基于乘积密码的概念来逼近任意可逆变换的方式。乘积密码是说，利用不同的两套或多套密码来加密，得到的结果比其中任意一种的加密效果都要强。特别的，Feistel建议使用替代和置换的反复使用。替代是指明文中的某一元素或某一组被唯一地替换成为密文中的某一元素或某一组；置换是改变明文元素顺序，但明文元素本身并不发生改变。这样的目的是产生混淆和扩散，这是香农提出的概念。其大致原理是，使得密文中的某一字符尽可能多地受到来自不同明文字符的影响，这样做可以有效抵御基于统计的密码分析。当然，最好的情况是所有统计规律都独立于密钥的选取，但这就是我们前面说的任意可逆变换，是不能够实际应用的。排除这种可能，由于密文的生成是明文和密钥的函数，因此，密文的统计规律不可避免出现密钥的信息。因此，大量使用替代和置换可以使这种关系变得复杂，挫败密码分析，这就是我们要的结果。 Feistel结构的基本特征 分组长度：不言而喻的，分组长度越大，密码的安全性就越高。正如前面分析的那样，这种安全性来源于混淆和扩散。一般的分组长度是64-bit，高级加密标准下是128-bit。 密钥长度：密钥越长安全性也显而易见的越高。但是这种安全性建立在牺牲了加解密速度之上。现代密码学中我们认为64-bit的密钥还不够，一般选取128-bit。 迭代轮数：迭代轮数是降低统计特征的最好方式。一般的推荐迭代轮数是16。 子密钥产生算法：我们在前面说过，我们要使用的是乘积密码的原理，因此，如何生成每一步的密钥是关键的问题。产生密钥的算法越复杂，安全性就越高。 轮函数\\(F\\)：轮函数是明文和密钥的函数。同样的，轮函数越复杂，密码安全性越高。 快速加解密：对称密码的优势之一就是速度快。作为对称加密算法的Feistel结构，也应当保持这样的优势。 简化分析难度：尽管我们喜欢把算法设计得尽可能使密码分析变得困难，然而将算法设计得易于分析也有它的好处。如果说算法被描述得简单一些，我们就更容易分析出其脆弱性，进而设计更可靠的加密算法。不过，我们后续要介绍的DES并没有简单的分析方式。 Feistel加密算法 本节介绍Feistel加密算法，其大致原理可以用下面的图来直观表示。当然我们也会对整个流程做出解释。 Feistel加密算法 不妨假设我们的明文输入是\\(2w\\)位的。我们先对其分组，分成两部分，每一个部分是\\(w\\)位长的，并且将它们分别记作\\(LE_0\\)和\\(RE_0\\)。我们对这个明文进行第一次迭代。我们如何获取\\(LE_1\\)呢？很简单，我们直接将输入数据的右半部分拷贝过来即可，即 \\[ \\begin{equation} LE_1=RE_0. \\end{equation} \\] 比较复杂的是\\(RE_1\\)的获得。 我们先选取明文的右半部分\\(RE_0\\)，对其作用轮函数\\(F\\)，密钥选择第一把子密钥，即这部分的运算结果是 \\[ F(RE_0,K_1). \\] 我们将上述得到的式子和\\(LE_0\\)作异或运算，于是得到我们需要的\\(RE_1\\)，这个过程用数学表达式表示就是 \\[ \\begin{equation} RE_1=LE_0\\oplus F(RE_0,K_1). \\end{equation} \\] 这就是第一轮迭代的结果。我们将这个迭代再重复15次，即一共迭代16次。上面式子(1)(2)用一般地表示方法即为 \\[ \\begin{equation} LE_i=RE_{i-1}, \\end{equation} \\] \\[ \\begin{equation} RE_i=LE_{i-1}\\oplus F(RE_{i-1},K_{i}). \\end{equation} \\] 当我们得到 \\(LE_{16}\\) 和 \\(RE_{16}\\) 后，我们对这两部分作最后一次交换，得到 \\[ LE_{17}=RE_{16}, \\] \\[ RE_{17}=LE_{16}, \\] 于是，上述两段拼接起来就是我们产生的密文。 这就是Feistel结构的加密过程。 Feistel解密算法 既然其加密算法看上去这么复杂，其解密算法会不会也很复杂呢？答案是并不是。其解密算法和加密算法完全一致，除了使用密钥的顺序和加密过程相反。这样究竟能不能复原出明文，这是我们关心的问题，下面我们给出证明。 我们要知道的是，\\(LE_i\\)和\\(RE_i\\)在我们知道密钥\\(K_i\\)的情况下能不能反解出前一步的密文。我们由式(4)可以知道 \\[ LE_{i-1}=RE_i\\oplus F(RE_{i-1},K_i), \\] 又由于\\(RE_{i-1}=LE_i\\)，有 \\[ LE_{i-1}=RE_i\\oplus F(LE_i,K_i). \\] 又显然有 \\[ RE_{i-1}=LE_i, \\] 也就是说，我们获得了密文后，便可以一层层代入解密。至于在加密过程中为什么要增加一步互换位置，是因为互换以后我们得到的密文中的右半部分 \\[ RD_0=RE_{17}=LE_{16}, \\] 这样，我们在解密过程中可以保持对右半部分使用轮函数，保证了加密解密算法的一致。 值得注意的是，上述论证过程中我们并没有假设轮函数具有什么性质，因为事实上，轮函数是可以任意选取的，这不影响我们的解密过程。我们后面要讲述的DES，实际上是Feistel结构的一个具体实现。 DES加密算法 DES加密算法以64位为分组，密钥长度为56位 （实际上，使用的密钥为64位，但是其中8位是校验位，不参与实际运算，因此说是56位）。加密的粗糙流程可见下图。 DES加密流程 我们获取到明文输入后，首先对其进行初始置换(\\(IP\\))，然后经过16轮迭代，最后经过左右互换（这点在Feistel结构中提到过），然后通过逆初始置换(\\(IP^{-1}\\))，得到密文输出。初始置换和逆初始置换是一对互逆运算。笔者认为其存在的意义仅仅是增加解密复杂度。每一轮加密的密钥来源于64位初始密钥生成的子密钥。以下我们解释一下DES的详细加密过程。 初始置换 初始置换和逆初始置换只在最开始和结束使用，其原理是地址置换，即将对应位置所指的地址的数据置换到该位上。下面给出了具体的初始置换和逆初始置换表。这里不多赘述。 初始置换 逆初始置换 轮函数的细节 我们先给出轮函数的示意图，然后再解释。 轮函数的细节 如同我们在Feistel结构中提到的，我们对64位明文信息分组称为左右两部分。由图上可知，轮函数外的步骤和Feistel结构完全一致，我们不多赘述。关键来看一下轮函数中的最重要的四步：E扩展置换，子密钥运算，S盒压缩和P置换。 E扩展置换 由于参加运算的子密钥是48位的，然而分组后我们的明文信息只有32位，因此，需要对明文信息扩展称为48位。E扩展是有对应表格的，它接受32位的输入，产生48位的输出。具体的扩展方式可以见下面的表格和例子。这样的扩展会产生16个重复的位。 Ebox 子密钥运算 将扩展置换结果与子密钥进行异或运算。 S盒压缩 上述的运算结果是48位的，然而，轮函数迭代后的位数是不能够增多的。因此，我们需要对48位的数据压缩，将之长度还原到32位。S盒压缩就是在完成这一步。S盒压缩接受48位的输入，产生32位的输出。其原理如下图。 S盒压缩过程 S盒首先将输入分成6位一组，共计8组。我们不妨假设输入是011001。首先我们获取输入的首尾两位，将其作为行号；剩余的四位作为列号。在上面的例子中，行号是1（01）；列号是12（1100）。我们查询S盒置换表，知道这一位数字是9，即1001。于是，1001就是我们的输出。对于其他7组也是如此，最后一共输出8组4位，共32位的结果。值得注意的是，S盒不止一个。其设计标准是不公开的，但S盒是公开的。 P置换 也是一种简单的置换，具有置换对照表。 子密钥的生成 我们输入的是64位的密钥。于是我们通过PC-1置换，将密钥的校验位去除，同时打乱密钥的顺序，得到56位的密钥。对这个56位密钥我们再次进行分组，分为左右两半部分各28位长度的密钥。我们把这个密钥称为\\(C_0D_0\\)。我们对其两部分分别进行左移，左移位数查表可见。对于每一次的左移结果，我们通过PC-2置换得到该次加密的子密钥。重复上述操作，我们可以得到所有加密过程需要的子密钥。 子密钥生成使用的PC-1、PC-2置换 DES密码的强度 对于P置换和S盒压缩是有要求的，就是要尽可能增加其中某一位对其他所有位变化的敏感度，也就是说，增加算法的扩散程度，来弥补分组算法本身难以逃脱统计攻击的特点。因此，不论是置换表格的设计，又或是子密钥的生成，都要严格遵循一个效应，我们称之为雪崩效应。雪崩效应说的是，明文或密钥的微小改变将对密文产生很大的影响，换句话说，明文和密钥的任何一位的改变会导致密文很多位的改变。这样，分析者搜索密钥的难度大大上升，加密算法也更加健壮。 但，DES密码并不是牢不可破的。其安全性一直备受质疑。曾在1998年，有一台专门针对DES加密算法的计算机成功破译了DES加密算法。但实际上，这种破译往往需要我们知道待破译的目标语言特点，例如语言特征，文件格式等等。因此，在不知道这些信息的情况下，破译DES依然是有难度的。不论如何，我们如今也有许多DES的替代加密方案例如AES和3DES。对这些方案，我们后续也会加以讨论。 不论如何，Feistel结构和DES加密算法仍旧是对称加密算法中的经典，理解它们对我们后续的深入学习是有百利而无一害的。","tags":["密码学"],"categories":["学习笔记"]},{"title":"KMP算法","path":"/posts/2da0528d/","content":"问题 给定一个字符串\\(A\\)，要求从字符串\\(A\\)中查找另一个字符串\\(B\\)是否出现。如果出现，返回查找的字符串\\(B\\)在\\(A\\)中的位置，否则返回-1。 最简单的解决方法——枚举法 枚举法当然可以解决这个问题：我们可以在从\\(A\\)字符串中取第一位，然后逐位往后与\\(B\\)串比较。如果匹配则返回答案；若不匹配，则从\\(A\\)字符串的第二位开始，重复上述操作，直到找到字符串位置或者字符串\\(A\\)被遍历完毕。 我们来分析一下这个的算法复杂度。我们假设字符串\\(A\\)和\\(B\\)的长度分别为\\(m\\)和\\(n\\)，那么这个算法的最差情况需要比较\\(m\\times n\\)次，即这个算法是\\(O(m\\times n)\\)的。 KMP算法 KMP算法是一个很好的解决算法，它可以 最多只扫描一次字符串\\(A\\) 就能完成任务，即它的算法复杂度是\\(O(n)\\)的。之所以被叫作KMP算法，是因为它是由Knuth、Morris、Pratt三个人提出的。下面来介绍一下该算法的思想。 简单的直观模拟 为了说明KMP的大致过程，我们先给出一个例子。 一个例子 我们参考上例，并且称大数组为\\(ch\\)，目标数组为\\(target\\)。我们从第一位开始逐个比较\\(ch\\)和\\(target\\)中的每一位，直到不匹配为止，如图(a)所示。我们发现，\\(ch[6]!=target[6]\\)。但是在\\(i\\leqslant 5\\)都有\\(ch[i]=target[i]\\)。我们此时不将\\(target\\)往后移动一位，选择往后移动两位，因为这个时候\\(ch[2]\\)到\\(ch[6]\\)仍然和目标字符串是匹配的。我们可以证明，这个位置是除了初始位置外第二个可能的匹配发生的位置。因为如果在此之前还存在一个匹配的字符串，那么我们要么已经找到了它，要么重定位会定位到它，而不是 \\(ch[2]\\) 。如果你能理解这点，这就是KMP算法的基本原理。 失效函数 失效函数原理 那么随之而来的问题是：我们如何确定应该向后移动几位呢？ 以及，如果每次向后移动都可以看做字符串\\(target\\)正在比较元素的后退，（正如上例中本在比较\\(target[6]\\)和\\(ch[6]\\)，向后移动后相当于比较\\(target[4]\\)和\\(ch[6]\\)） 那么到底后退几位呢？ 如果我们把字符串中正在比较的元素位置记作\\(j\\)，后退后正在比较\\(j^\\prime\\)，那么我们可以知道它们满足：\\(target[0]\\)到\\(target[j^\\prime]\\)之间的字符串和\\(target[j-j^\\prime]\\)到\\(target[j]\\)之间的字符串完全相同。这里需要读者仔细理解一下，我们实际上取的\\(j^\\prime\\)是使得\\(target\\)中前\\(j^\\prime+1\\)和后\\(j^\\prime+1\\)个字符完全相同，也就是我们在前一节说的直观模拟的结果。 我们把\\(j\\)和\\(j^\\prime\\)的对应关系称为失效函数，即 \\[ j^\\prime =P[j]. \\] 有了这个对应关系，我们就可以轻松决定，当字符串正在比较位置\\(i,j\\)相同，即\\(ch[i]=target[j]\\)时，但位置\\(i+1,j+1\\)不同，即\\(ch[i+1] eq target[j+1]\\)时，\\(j\\)需要更新成什么了。 失效函数的算法 我们从上述论断中可以知道，失效函数的产生只和目标数组\\(target\\)有关，因此我们可以对目标数组预处理，得到其失效函数。那么，失效函数的算法是什么呢？ 首先，我们知道对于\\(target[0]\\)，是没有满足失效函数定义的下标\\(j^\\prime\\)的，那么，我们定义这种条件下，其失效函数值为-1。然后我们用递推的方式求出其他元素的失效函数。我们现在要求下标为\\(j\\)的元素的失效函数，那么我们考察\\(j-1\\)位置上的元素，其失效函数的值为\\(j_0\\)，那么也就是说，\\(target[0]\\)到\\(target[j_0]\\)之间的字符串和\\(target[j-1-j_0]\\)到\\(target[j-1]\\)之间的字符串完全相同，那么我们只要比较\\(target[j_0+1]\\)和\\(target[j]\\)是否相同，即比较\\(target[P[j-1]+1]\\)和\\(target[j]\\)是否相同。如果也相同，那么\\(P[j-1]+1=P[j]\\)；否则，我们可以令\\(P[j_0]\\)是新的\\(j_0\\)，继续反复上次的比较，直到找到\\(target[0]\\)并且\\(target[0]\\)和\\(target[j]\\)也不相等，那么其失效函数的值为-1 。 失效函数的实现 这节给出失效函数failurefunc()的实现。 123456789101112131415int* failurefunc(const seqString&amp; target)const&#123; int* p=new int[target.len];//申请一个数组，存放失效函数 int j; p[0]=-1;//首元素的失效函数值为-1 for(int i=1;i&lt;target.len;++i)&#123; j=i-1;//往前退一位 while(j&gt;=0&amp;&amp;target.data[p[j]+1]!=target.data[i]) j=p[j];//如果最长相同子序列不存在，那么缩短相同子序列长度 if(j&lt;0) p[i]=-1;//直到找完都没有找到，则失效函数为-1 else p[i]=p[j]+1;//找到了，更新失效函数的值 &#125;//end for return p;&#125;//end function 查找函数 有了上面的失效函数，我们可以完成KMP算法中的查找部分了。 查找函数的原理 查找函数使用两个指针\\(i\\)和\\(j\\)，分别指向字符串\\(ch\\)和\\(target\\)中正在比较的元素。从两字符串头开始，对\\(i,j\\)一同自增，直到发现\\(ch[i]!=target[j]\\)就停止；此时，利用失效函数，对\\(j\\)的值进行更新，更新为其前一个元素失效函数的值后的元素，即\\(P[j-1]+1\\)，然后重新比较\\(i\\)和\\(j\\)，重复上述步骤，直到\\(j=0\\)时还是无法匹配，则固定\\(j\\)，对\\(i\\)自增，直到匹配为止。搜索过程退出的条件是：找到了\\(target\\)的位置，即\\(j=target.len-1\\)；或者未找到，即\\(i=ch.len-1\\)。 查找函数的实现 本节实现查找函数。 12345678910111213141516171819int find(const seqString &amp; ch, const seqString &amp; target)&#123; int* p=NULL;//存放失效函数 p=failurefunc(target);//获取失效函数 int i=j=0;//定位指针 while(i&lt;ch.len&amp;&amp;j&lt;target.len)&#123; if(ch.data[i]==target.data[j]) &#123;i++;j++;&#125;//相等则自增 else if(j==0) i++;//不相等但是j已经为零时，i自增 else j=p[j-1]+1;//否则更新j的值 &#125;//end while delete p;//释放内存 if(j==target.len) //比较完最后一个字符后，j又自增了一次，所以应该是最后一个元素的下标+1 return i-j;//如果找到了以后才退出，那么返回位置 else return -1;//否则就是没找到，返回未找到&#125; 后记 KMP算法的时间复杂度是\\(O(n)\\)的，因为我们即便可能需要扫描目标字符串许多遍，但主字符串我们只需要扫描一遍，也就是说不会超过\\(n\\)次。KMP算法为什么能节省时间，本质上使我们利用了扫描匹配过程中匹配失败的信息。对于匹配失败的节点，我们利用两个指针直接跳过了许多次扫描，因而节省了时间。可以说，KMP算法相比于枚举法有着更高的信息利用率。","tags":["数据结构","算法"],"categories":["学习笔记"]},{"title":"RSA加密算法","path":"/posts/c8b4e820/","content":"加密算法 谈到加密算法，我们不得不谈一下密码学中加密算法的两个分支：对称加密和非对称加密。 对称加密算法（以单表替代密码为例） 我们假设Felix要向你们之间的某位读者发送一段信息\\(m\\)，为方便起见，我们假设这段信息是\"THANKYOUFORFOLLOWINGME\"。现在，为了使这段信息不被外人所知，需要对其加密。我们假设加密方式为：所有用后一位字母替代，那么上述的这段信息就被加密为：\"UIBOLZPVGPSGPMMPXJOHNF\"，这是不可读的。当读者接收到这段信息时，只需要将加密后的信息往前倒退一位，便可以得到原始信息。我们把原始信息称为明文，加密后的信息称为密文，加密方式（在上例中体现为字母的替代）称为加密算法，解密方式（在上例中体现为字母的替代）称为解密算法，加密时移动的位数1称为加密密钥，解密时移动的位数1称为解密密钥。 上面这种加密方式一般被称为单表替代密码，上述的例子又是其中十分特殊的一种，称为凯撒密码。我们观察可以知道，加密密钥和解密密钥是相同的，我们把具有这种性质的加密算法称为对称加密算法。 对称加密算法是有好处的：其计算量小，加密简单，用于加密和解密的密钥相同，算法只需要选取可逆映射即可。但对称加密也存在一些问题：双方在通信前需要互相商定密钥，并且在通信过程中，任何一方的密钥泄露都将使得所有通信被破解；其次，任何两者之间的通信都需要选取不同的密钥，这在通信网复杂的情况下，每个通信节点都需要储存数量庞大的密钥，给用户带来负担。 当然，密钥泄露的问题不是不可解决的。我们可以在每一次通信都使用不同的密钥，这样，密文在理论上是牢不可破的。但是这又会带来问题，我们如何获得这么庞大数量的密钥呢？我们又如何储存呢？密钥的分发在这种情况下变成了棘手的问题。所以，一次一密的加密方式在实际应用中是不广泛的。 非对称加密 随即而来进入我们脑海的一种加密方式就是非对称加密，即加密密钥和解密密钥不相同的加密方式。我们一般称前者为公钥，后者为私钥，因为前者是公开给所有人的，后者是密文接收方自己保存的。我们知道，由于加密和解密是逆运算，我们是有可能通过暴力破解求出加密方式的逆运算的。所以，为了保证安全性，非对称加密的算法一般都十分复杂，运算量相比于对称加密算法繁琐得多，因此，非对称加密牺牲了加密效率，换来了更高的安全性。下面我们来讨论一下非对称加密中的典型加密方式，即RSA加密。 RSA加密算法 基于的数学运算原理——模运算 首先我们来思考一个问题，有什么方式使得攻击者知道加密方式的情况下很难求算出其逆运算？有一种运算符合类似的性质：其正向运算十分简单，但逆运算极其复杂，它是模运算（Mod）。模运算就是我们一般说的求余。其正向运算是很简单的，例如 \\[ 3^3\\ \\textrm{mod}\\ 7=6, \\] 完成这个运算只需要一个简单的除法即可，但是设想，如果给出的形式是方程，即 \\[ 3^x\\ \\textrm{mod}\\ 7=6, \\] 求解满足上述方程的x的值，其运算是比较复杂的，因为我们不知道其商的值，也就不能快速利用乘法求算\\(x\\)，一般我们会使用枚举法求算其解。但是如果方程是 \\[ 3^x\\ \\textrm{mod}\\ 7156464845153468615315646=6, \\] 这时候，枚举法也变得十分困难了，这个方程已经是计算上不可解的了。因此，模运算也被称为单向运算。RSA就是利用了模运算的这点性质。 加密算法和解密算法确定 知道了我们要使用模运算作为加密和解密算法，那么我们不妨假设明文信息是\\(m\\)（message），密文信息是\\(c\\)（cipher），公钥为\\(e\\)，私钥为\\(d\\)，于是我们可以得到 \\[ \\begin{cases} m^e\\ \\textrm{mod}\\ N=c,\\\\ c^d\\ \\textrm{mod}\\ N=m. \\end{cases} \\] 消去密文\\(c\\)，上式可化为 \\[ (m^e\\ \\textrm{mod}\\ N)^d\\ \\textrm{mod}\\ N=m, \\] 可以证明上式等价于 \\[ m^{ed}\\ \\textrm{mod}\\ N=m. \\] 这个结论先放在这里，我们后续会使用到它。 欧拉函数和欧拉定理 为了充分理解RSA密码的数学原理，我们需要先提到欧拉函数和欧拉定理。 欧拉函数 首先介绍一下欧拉函数：假设给定一个正整数\\(n\\)，欧拉函数\\(\\varphi(n)\\)的值是不超过\\(n\\)的与其互质的正整数的数目，例如不超过6的与6互质的正整数有1和5，那么我们就说，\\(\\varphi(6)=2\\)。一般求解欧拉函数的值时，我们经常采用素因数分解的方式，让我们来看一个例子：求解\\(\\varphi(100)\\)的值。我们对其质因数分解，得到 \\[ 100=2^2\\cdot 5^2。 \\] 那么其与其互质的整数数量为 \\[ \\varphi(100)=100\\times(1-\\dfrac{1}{2})\\times(1-\\dfrac{1}{5})=40. \\] 对于任意正整数\\(x\\)，假设其各个质因数为\\(p_i\\)，那么其欧拉函数的值为 \\[ \\varphi(x)=x\\prod^n_{i=1}(1-\\dfrac{1}{p_i}). \\] 显然，这样计算一个正整数的欧拉函数是很复杂的。但如果上式中的\\(x\\)是质数呢？问题就变得非常简单，因为这时\\(P_i=\\{x\\}\\)。于是我们可以知道，质数\\(p\\)的欧拉函数为 \\[ \\varphi(p)=p-1. \\] 同样的，如果对于两个互质的正整数\\(p,q\\)，其乘积的欧拉函数就等于欧拉函数的乘积，即 \\[ \\varphi(p\\times q)=\\varphi(p)\\times \\varphi(q). \\] 这为我们求解欧拉函数提供了一个很好的解决方式。 欧拉定理 欧拉定理是数论中的重要定理，我们这里只做介绍，不作证明。欧拉定理说的是，对于互质的两正整数\\(m\\)和\\(n\\)，满足以下关系恒成立： \\[ m^{\\varphi(n)}\\equiv1\\ (\\textrm{mod}\\ n), \\] 我们对上式两边同时取\\(k\\)次幂，得到 \\[ m^{k\\varphi(n)}\\equiv1\\ (\\textrm{mod}\\ n), \\] 两边同时乘上\\(m\\)，有 \\[ m^{k\\varphi(n)+1}\\equiv m\\ (\\textrm{mod}\\ n), \\] 改写得到 \\[ m^{k\\varphi(n)+1}\\ \\textrm{mod}\\ n= m. \\] 这是我们需要的欧拉定理的形式。 密钥的生成 读者是否还记得我们在确定算法的时候找到了公钥和私钥的关系式？即 \\[ m^{ed}\\ \\textrm{mod}\\ N=m. \\] 与我们得到的欧拉定理的形式 \\[ m^{k\\varphi(n)+1}\\ \\textrm{mod}\\ n=m. \\] 相比，我们发现，这时我们只需要使得 \\[ ed=k\\varphi(N)+1， \\] 即对于任何一个公钥\\(e\\)，我们私钥\\(d\\)的生成方式为计算\\(d\\)使得 \\[ ed\\ \\textrm{mod}\\ \\varphi(N)=1. \\] 这时我们可以利用到一条数学定理：如果两正整数互质（这里表现为\\(d\\)与\\(\\varphi(N)\\)互质），那么一定存在\\(d\\)满足上述关系，即\\(ed-1\\)被\\(\\varphi(N)\\)整除，我们称这样的\\(d\\)为模反元素。 所以，我们只要保证公钥\\(e\\)和求得的\\(\\varphi(N)\\)互质，那么私钥\\(d\\)的存在性是不言而喻的。那么现在问题的关键就是：如何确定\\(\\varphi(N)\\)和\\(e\\)的值。 我们任意选取足够大的两个质数\\(p\\)和\\(q\\)，这是我们产生\\(\\varphi(N)\\)的来源。我们令\\(N=p\\cdot q\\)，这样的\\(N\\)通常是非常大的，理论上计算\\(\\varphi(N)\\)需要对其进行质因数分解，然而对不知道\\(p\\)和\\(q\\)的人来说，这几乎是不可能的事情，因为\\(N\\)的质因数分解被证明是计算上不可行的了。但作为密钥的分发方，我们却很容易解出，因为我们选取的是两个质数，利用欧拉函数的性质，我们很容易知道 \\[ \\varphi(N)=\\varphi(p\\cdot q)=\\varphi(p)\\cdot\\varphi(q)=(p-1)(q-1). \\] 有了这个解，我们只需要任意取一个和\\(\\varphi(N)\\)互质的数就行了。由此，我们将\\((e,N)\\)作为公钥发送出去，待我们计算出\\(d\\)后，保留\\((d,N)\\)作为私钥即可。销毁\\(p\\)和\\(q\\)，这样这组公钥私钥几乎是无法被破解的了。 加密流程总结 至此，我们已经知道了加密基于的数学原理和方法，这里我们来一些总结。 步骤 内容 生成 1 选取两个不相等的足够大的质数 \\(p\\)和\\(q\\) 2 计算它们的乘积\\(N=p\\times q\\) \\(N\\) 3 利用\\(N\\)的因数计算其欧拉函数\\(\\varphi(N)=(p-1)\\times(q-1)\\) \\(\\varphi(N)\\) 4 选取任一与\\(\\varphi(N)\\)互质的整数\\(e\\) 公钥成员\\(e\\) 5 计算模反元素\\(d\\)：\\(ed\\ \\textrm{mod}\\ \\varphi(N)=1\\) 私钥成员\\(d\\) 6 公布公钥\\((e,N)\\) 公钥\\((e,N)\\) 7 保存私钥\\((d,N)\\) 私钥\\((d,N)\\) 8 销毁\\(p\\)和\\(q\\) 无 这就是RSA加密算法的原理和流程。 关于关键的\\(p\\)和\\(q\\) 我们知道，如果两个数很接近，那么它们的差值一定很小。如果我们选取的\\(p\\)和\\(q\\)相差不大，那么RSA在这种情况下是很容易被攻破的。我们可以假设\\(p&gt;q\\)并且 \\[ p=a+b,\\quad q=a-b, \\] 那么大数\\(N\\)就可以被表示为 \\[ N=p\\times q=(a+b)(a-b)=a^2-b^2. \\] 由于\\(b\\)很小，所以\\(a\\)和\\(\\sqrt{N}\\)的值非常接近，于是我们可以轻易倒推出用于产生密钥的\\(p\\)和\\(q\\)的值。这种情况下，RSA的安全性很低。但好在幸运的是，应用中不会产生这样的错误，所以RSA依然是很可靠的加密方式。 后记 从对于RSA彻底的分析来看，密码学在本质上是数学的实际应用。笔者在理解RSA密码加密的学习过程中，其实更多的时候都在了解其基于的数学原理，而并非大多数人所认为的加密过程。站在一个高度看RSA密码，其实其可靠性是由于人类对质因数分解掌握的不完全所保证的，因为知道公钥\\((e,N)\\)，从理论上是可以破解私钥的，只是实际不可行罢了。当然，我们也不能因此质疑RSA密码的可靠性，因为密码学对密码是否可用的标准一直只有两条：破解密码耗费的资源大于信息本身，或者破解密码需要的时间远大于信息的时效性，而并没有将牢不可破作为其中的标准。 RSA密码在历史上首次是被政府发现的，然后其就一直作为机密被尘封起来。直到1977年，三位麻省理工的数学家独立发掘出这种公钥私钥计算方法，然后才成为了如今广泛使用的RSA加密算法。这个算法也由他们的名字命名：Ron Rivest,Adi Shamir,Leonard Adleman。 公开RSA的三位数学家 回过来看这个优美的表达式 \\[ d=\\dfrac{k\\varphi(N)+1}{e}, \\] 一对看似无关的数字却连接着探索真相的答案，一个看似简单的算法却暗藏着千年未解的数学难题，这或许就是密码最终的魅力。","tags":["密码学"],"categories":["学习笔记"]},{"title":"友链","path":"/link/index.html","content":"友情链接 置顶链接 全站友链 友情链接 与我互换友链 请前往友链Github仓库新建issue，按照友链模板填写内容，等待issue被打上active标签后，你就可以在本页面找到你的链接了。 我的信息 1234 - title: Felix Chen url: https://blog.felixchen0707.cn/ avatar: https://i.imgtg.com/2022/06/06/n3ORs.jpg decription: 所见一切皆是奇迹。"},{"title":"更多","path":"/more/index.html","content":""},{"path":"/bbtalk/index.html","content":"动态"},{"path":"/link/rss/index.html","content":""},{"title":"开始翻阅笔记","path":"/wiki/notes/index.html","content":"尝试"},{"title":"概述","path":"/wiki/notes/computer-organization-and-architecture/index.html","content":"计算机的基本组成 Von Neumann structure 早期的冯诺依曼体系结构以运算器为核心，数据的处理、输入输出和存储都要经过运算器，导致计算机的输入、输出、运算操作只能串行执行。 改良后的计算机结构选取存储器为中心结构，使得运算器可以将绝大多数的时间全部投入数据的运算和处理之中。如下图所示： 计算机的执行过程 寄存器一般而言分为两类：通用寄存器和专用寄存器。通用寄存器，一般用于保存程序运行期间的中间结果。 在主存储器中，存在两个专用寄存器：MAR(Memory Address Register)，存储器地址寄存器和MDR(Memory Data Register)，存储器数据寄存器。在控制器中也存在两个寄存器：PC(Program Counter)，程序计数器，储存正在执行的指令的地址，每次执行完一条指令后自增，指向下一条地址；IR(Instruction Register)，指令寄存器。 执行程序时，首先依据控制器PC中的地址从存储器中读取指令内容至IR，而后由控制系统分析IR的功能，进而执行后续操作。上述过程会一直循环。 指令字长、存储字长和机器字长 指令字长，指计算机每条指令的字节长度；存储字长，指计算机中的存储器每次能够访问的字节长度，一般是MDR的长度；机器字长，指计算机在同一时间段内能够处理的数据位数。 计算机的性能指标 执行时间和吞吐率。 执行时间常用CPU时间来描述 CPU时间：给定程序任务占用处理器的时间，不包含输入输出的时间消耗。 \\[ \\text{CPU时间}=\\text{指令条数}\\textrm{IC}\\times\\text{平均执行每条指令所占用的时间}, \\] \\[ \\text{平均执行每条指令所占用的时间}=\\text{平均执行每条指令所花费的时钟周期}\\textrm{CPI}\\times\\text{时钟周期}. \\] 吞吐率常用MIPS和FLOPS描述 MIPS：每秒执行百万条指令数；FLOPS：每秒进行的浮点运算次数。"}]